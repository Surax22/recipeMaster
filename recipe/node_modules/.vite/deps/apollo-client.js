import {
  ApolloLink,
  bundle_esm_default,
  execute
} from "./chunk-C6QRSBR2.js";
import {
  InvariantError,
  argumentsObjectFromField,
  buildQueryFromSelectionSet,
  canUseWeakMap,
  cloneDeep,
  createFragmentMap,
  equal,
  getDefaultValues,
  getFragmentDefinitions,
  getMainDefinition,
  getOperationDefinition,
  getOperationName,
  graphQLResultHasError,
  hasClientExports,
  hasDirectives,
  invariant,
  isField,
  isInlineFragment,
  mergeDeep,
  mergeDeepArray,
  removeClientSetsFromDocument,
  removeConnectionDirectiveFromDocument,
  resultKeyNameFromField,
  shouldInclude,
  tryFunctionOrLogError
} from "./chunk-6Z7NORUY.js";
import {
  BREAK,
  visit
} from "./chunk-TGUKOLNW.js";
import "./chunk-TWLJ45QX.js";

// node_modules/apollo-client/node_modules/tslib/tslib.es6.js
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (b2.hasOwnProperty(p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}

// node_modules/symbol-observable/es/ponyfill.js
function symbolObservablePonyfill(root2) {
  var result2;
  var Symbol2 = root2.Symbol;
  if (typeof Symbol2 === "function") {
    if (Symbol2.observable) {
      result2 = Symbol2.observable;
    } else {
      result2 = Symbol2("observable");
      Symbol2.observable = result2;
    }
  } else {
    result2 = "@@observable";
  }
  return result2;
}

// node_modules/symbol-observable/es/index.js
var root;
if (typeof self !== "undefined") {
  root = self;
} else if (typeof window !== "undefined") {
  root = window;
} else if (typeof global !== "undefined") {
  root = global;
} else if (typeof module !== "undefined") {
  root = module;
} else {
  root = Function("return this")();
}
var result = symbolObservablePonyfill(root);
var es_default = result;

// node_modules/apollo-client/bundle.esm.js
var NetworkStatus;
(function(NetworkStatus2) {
  NetworkStatus2[NetworkStatus2["loading"] = 1] = "loading";
  NetworkStatus2[NetworkStatus2["setVariables"] = 2] = "setVariables";
  NetworkStatus2[NetworkStatus2["fetchMore"] = 3] = "fetchMore";
  NetworkStatus2[NetworkStatus2["refetch"] = 4] = "refetch";
  NetworkStatus2[NetworkStatus2["poll"] = 6] = "poll";
  NetworkStatus2[NetworkStatus2["ready"] = 7] = "ready";
  NetworkStatus2[NetworkStatus2["error"] = 8] = "error";
})(NetworkStatus || (NetworkStatus = {}));
function isNetworkRequestInFlight(networkStatus) {
  return networkStatus < 7;
}
var Observable = function(_super) {
  __extends(Observable2, _super);
  function Observable2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Observable2.prototype[es_default] = function() {
    return this;
  };
  Observable2.prototype["@@observable"] = function() {
    return this;
  };
  return Observable2;
}(bundle_esm_default);
function isNonEmptyArray(value) {
  return Array.isArray(value) && value.length > 0;
}
function isApolloError(err) {
  return err.hasOwnProperty("graphQLErrors");
}
var generateErrorMessage = function(err) {
  var message = "";
  if (isNonEmptyArray(err.graphQLErrors)) {
    err.graphQLErrors.forEach(function(graphQLError) {
      var errorMessage = graphQLError ? graphQLError.message : "Error message not found.";
      message += "GraphQL error: " + errorMessage + "\n";
    });
  }
  if (err.networkError) {
    message += "Network error: " + err.networkError.message + "\n";
  }
  message = message.replace(/\n$/, "");
  return message;
};
var ApolloError = function(_super) {
  __extends(ApolloError2, _super);
  function ApolloError2(_a) {
    var graphQLErrors = _a.graphQLErrors, networkError = _a.networkError, errorMessage = _a.errorMessage, extraInfo = _a.extraInfo;
    var _this = _super.call(this, errorMessage) || this;
    _this.graphQLErrors = graphQLErrors || [];
    _this.networkError = networkError || null;
    if (!errorMessage) {
      _this.message = generateErrorMessage(_this);
    } else {
      _this.message = errorMessage;
    }
    _this.extraInfo = extraInfo;
    _this.__proto__ = ApolloError2.prototype;
    return _this;
  }
  return ApolloError2;
}(Error);
var FetchType;
(function(FetchType2) {
  FetchType2[FetchType2["normal"] = 1] = "normal";
  FetchType2[FetchType2["refetch"] = 2] = "refetch";
  FetchType2[FetchType2["poll"] = 3] = "poll";
})(FetchType || (FetchType = {}));
var hasError = function(storeValue, policy) {
  if (policy === void 0) {
    policy = "none";
  }
  return storeValue && (storeValue.networkError || policy === "none" && isNonEmptyArray(storeValue.graphQLErrors));
};
var ObservableQuery = function(_super) {
  __extends(ObservableQuery2, _super);
  function ObservableQuery2(_a) {
    var queryManager = _a.queryManager, options = _a.options, _b = _a.shouldSubscribe, shouldSubscribe = _b === void 0 ? true : _b;
    var _this = _super.call(this, function(observer) {
      return _this.onSubscribe(observer);
    }) || this;
    _this.observers = /* @__PURE__ */ new Set();
    _this.subscriptions = /* @__PURE__ */ new Set();
    _this.isTornDown = false;
    _this.options = options;
    _this.variables = options.variables || {};
    _this.queryId = queryManager.generateQueryId();
    _this.shouldSubscribe = shouldSubscribe;
    var opDef = getOperationDefinition(options.query);
    _this.queryName = opDef && opDef.name && opDef.name.value;
    _this.queryManager = queryManager;
    return _this;
  }
  ObservableQuery2.prototype.result = function() {
    var _this = this;
    return new Promise(function(resolve, reject) {
      var observer = {
        next: function(result2) {
          resolve(result2);
          _this.observers.delete(observer);
          if (!_this.observers.size) {
            _this.queryManager.removeQuery(_this.queryId);
          }
          setTimeout(function() {
            subscription.unsubscribe();
          }, 0);
        },
        error: reject
      };
      var subscription = _this.subscribe(observer);
    });
  };
  ObservableQuery2.prototype.currentResult = function() {
    var result2 = this.getCurrentResult();
    if (result2.data === void 0) {
      result2.data = {};
    }
    return result2;
  };
  ObservableQuery2.prototype.getCurrentResult = function() {
    if (this.isTornDown) {
      var lastResult = this.lastResult;
      return {
        data: !this.lastError && lastResult && lastResult.data || void 0,
        error: this.lastError,
        loading: false,
        networkStatus: NetworkStatus.error
      };
    }
    var _a = this.queryManager.getCurrentQueryResult(this), data = _a.data, partial = _a.partial;
    var queryStoreValue = this.queryManager.queryStore.get(this.queryId);
    var result2;
    var fetchPolicy = this.options.fetchPolicy;
    var isNetworkFetchPolicy = fetchPolicy === "network-only" || fetchPolicy === "no-cache";
    if (queryStoreValue) {
      var networkStatus = queryStoreValue.networkStatus;
      if (hasError(queryStoreValue, this.options.errorPolicy)) {
        return {
          data: void 0,
          loading: false,
          networkStatus,
          error: new ApolloError({
            graphQLErrors: queryStoreValue.graphQLErrors,
            networkError: queryStoreValue.networkError
          })
        };
      }
      if (queryStoreValue.variables) {
        this.options.variables = __assign(__assign({}, this.options.variables), queryStoreValue.variables);
        this.variables = this.options.variables;
      }
      result2 = {
        data,
        loading: isNetworkRequestInFlight(networkStatus),
        networkStatus
      };
      if (queryStoreValue.graphQLErrors && this.options.errorPolicy === "all") {
        result2.errors = queryStoreValue.graphQLErrors;
      }
    } else {
      var loading = isNetworkFetchPolicy || partial && fetchPolicy !== "cache-only";
      result2 = {
        data,
        loading,
        networkStatus: loading ? NetworkStatus.loading : NetworkStatus.ready
      };
    }
    if (!partial) {
      this.updateLastResult(__assign(__assign({}, result2), { stale: false }));
    }
    return __assign(__assign({}, result2), { partial });
  };
  ObservableQuery2.prototype.isDifferentFromLastResult = function(newResult) {
    var snapshot = this.lastResultSnapshot;
    return !(snapshot && newResult && snapshot.networkStatus === newResult.networkStatus && snapshot.stale === newResult.stale && equal(snapshot.data, newResult.data));
  };
  ObservableQuery2.prototype.getLastResult = function() {
    return this.lastResult;
  };
  ObservableQuery2.prototype.getLastError = function() {
    return this.lastError;
  };
  ObservableQuery2.prototype.resetLastResults = function() {
    delete this.lastResult;
    delete this.lastResultSnapshot;
    delete this.lastError;
    this.isTornDown = false;
  };
  ObservableQuery2.prototype.resetQueryStoreErrors = function() {
    var queryStore = this.queryManager.queryStore.get(this.queryId);
    if (queryStore) {
      queryStore.networkError = null;
      queryStore.graphQLErrors = [];
    }
  };
  ObservableQuery2.prototype.refetch = function(variables) {
    var fetchPolicy = this.options.fetchPolicy;
    if (fetchPolicy === "cache-only") {
      return Promise.reject(false ? new InvariantError(1) : new InvariantError("cache-only fetchPolicy option should not be used together with query refetch."));
    }
    if (fetchPolicy !== "no-cache" && fetchPolicy !== "cache-and-network") {
      fetchPolicy = "network-only";
    }
    if (!equal(this.variables, variables)) {
      this.variables = __assign(__assign({}, this.variables), variables);
    }
    if (!equal(this.options.variables, this.variables)) {
      this.options.variables = __assign(__assign({}, this.options.variables), this.variables);
    }
    return this.queryManager.fetchQuery(this.queryId, __assign(__assign({}, this.options), { fetchPolicy }), FetchType.refetch);
  };
  ObservableQuery2.prototype.fetchMore = function(fetchMoreOptions) {
    var _this = this;
    false ? invariant(fetchMoreOptions.updateQuery, 2) : invariant(fetchMoreOptions.updateQuery, "updateQuery option is required. This function defines how to update the query data with the new results.");
    var combinedOptions = __assign(__assign({}, fetchMoreOptions.query ? fetchMoreOptions : __assign(__assign(__assign({}, this.options), fetchMoreOptions), { variables: __assign(__assign({}, this.variables), fetchMoreOptions.variables) })), { fetchPolicy: "network-only" });
    var qid = this.queryManager.generateQueryId();
    return this.queryManager.fetchQuery(qid, combinedOptions, FetchType.normal, this.queryId).then(function(fetchMoreResult) {
      _this.updateQuery(function(previousResult) {
        return fetchMoreOptions.updateQuery(previousResult, {
          fetchMoreResult: fetchMoreResult.data,
          variables: combinedOptions.variables
        });
      });
      _this.queryManager.stopQuery(qid);
      return fetchMoreResult;
    }, function(error) {
      _this.queryManager.stopQuery(qid);
      throw error;
    });
  };
  ObservableQuery2.prototype.subscribeToMore = function(options) {
    var _this = this;
    var subscription = this.queryManager.startGraphQLSubscription({
      query: options.document,
      variables: options.variables
    }).subscribe({
      next: function(subscriptionData) {
        var updateQuery = options.updateQuery;
        if (updateQuery) {
          _this.updateQuery(function(previous, _a) {
            var variables = _a.variables;
            return updateQuery(previous, {
              subscriptionData,
              variables
            });
          });
        }
      },
      error: function(err) {
        if (options.onError) {
          options.onError(err);
          return;
        }
        invariant.error("Unhandled GraphQL subscription error", err);
      }
    });
    this.subscriptions.add(subscription);
    return function() {
      if (_this.subscriptions.delete(subscription)) {
        subscription.unsubscribe();
      }
    };
  };
  ObservableQuery2.prototype.setOptions = function(opts) {
    var oldFetchPolicy = this.options.fetchPolicy;
    this.options = __assign(__assign({}, this.options), opts);
    if (opts.pollInterval) {
      this.startPolling(opts.pollInterval);
    } else if (opts.pollInterval === 0) {
      this.stopPolling();
    }
    var fetchPolicy = opts.fetchPolicy;
    return this.setVariables(this.options.variables, oldFetchPolicy !== fetchPolicy && (oldFetchPolicy === "cache-only" || oldFetchPolicy === "standby" || fetchPolicy === "network-only"), opts.fetchResults);
  };
  ObservableQuery2.prototype.setVariables = function(variables, tryFetch, fetchResults) {
    if (tryFetch === void 0) {
      tryFetch = false;
    }
    if (fetchResults === void 0) {
      fetchResults = true;
    }
    this.isTornDown = false;
    variables = variables || this.variables;
    if (!tryFetch && equal(variables, this.variables)) {
      return this.observers.size && fetchResults ? this.result() : Promise.resolve();
    }
    this.variables = this.options.variables = variables;
    if (!this.observers.size) {
      return Promise.resolve();
    }
    return this.queryManager.fetchQuery(this.queryId, this.options);
  };
  ObservableQuery2.prototype.updateQuery = function(mapFn) {
    var queryManager = this.queryManager;
    var _a = queryManager.getQueryWithPreviousResult(this.queryId), previousResult = _a.previousResult, variables = _a.variables, document = _a.document;
    var newResult = tryFunctionOrLogError(function() {
      return mapFn(previousResult, { variables });
    });
    if (newResult) {
      queryManager.dataStore.markUpdateQueryResult(document, variables, newResult);
      queryManager.broadcastQueries();
    }
  };
  ObservableQuery2.prototype.stopPolling = function() {
    this.queryManager.stopPollingQuery(this.queryId);
    this.options.pollInterval = void 0;
  };
  ObservableQuery2.prototype.startPolling = function(pollInterval) {
    assertNotCacheFirstOrOnly(this);
    this.options.pollInterval = pollInterval;
    this.queryManager.startPollingQuery(this.options, this.queryId);
  };
  ObservableQuery2.prototype.updateLastResult = function(newResult) {
    var previousResult = this.lastResult;
    this.lastResult = newResult;
    this.lastResultSnapshot = this.queryManager.assumeImmutableResults ? newResult : cloneDeep(newResult);
    return previousResult;
  };
  ObservableQuery2.prototype.onSubscribe = function(observer) {
    var _this = this;
    try {
      var subObserver = observer._subscription._observer;
      if (subObserver && !subObserver.error) {
        subObserver.error = defaultSubscriptionObserverErrorCallback;
      }
    } catch (_a) {
    }
    var first = !this.observers.size;
    this.observers.add(observer);
    if (observer.next && this.lastResult)
      observer.next(this.lastResult);
    if (observer.error && this.lastError)
      observer.error(this.lastError);
    if (first) {
      this.setUpQuery();
    }
    return function() {
      if (_this.observers.delete(observer) && !_this.observers.size) {
        _this.tearDownQuery();
      }
    };
  };
  ObservableQuery2.prototype.setUpQuery = function() {
    var _this = this;
    var _a = this, queryManager = _a.queryManager, queryId = _a.queryId;
    if (this.shouldSubscribe) {
      queryManager.addObservableQuery(queryId, this);
    }
    if (this.options.pollInterval) {
      assertNotCacheFirstOrOnly(this);
      queryManager.startPollingQuery(this.options, queryId);
    }
    var onError = function(error) {
      _this.updateLastResult(__assign(__assign({}, _this.lastResult), { errors: error.graphQLErrors, networkStatus: NetworkStatus.error, loading: false }));
      iterateObserversSafely(_this.observers, "error", _this.lastError = error);
    };
    queryManager.observeQuery(queryId, this.options, {
      next: function(result2) {
        if (_this.lastError || _this.isDifferentFromLastResult(result2)) {
          var previousResult_1 = _this.updateLastResult(result2);
          var _a2 = _this.options, query_1 = _a2.query, variables = _a2.variables, fetchPolicy_1 = _a2.fetchPolicy;
          if (queryManager.transform(query_1).hasClientExports) {
            queryManager.getLocalState().addExportedVariables(query_1, variables).then(function(variables2) {
              var previousVariables = _this.variables;
              _this.variables = _this.options.variables = variables2;
              if (!result2.loading && previousResult_1 && fetchPolicy_1 !== "cache-only" && queryManager.transform(query_1).serverQuery && !equal(previousVariables, variables2)) {
                _this.refetch();
              } else {
                iterateObserversSafely(_this.observers, "next", result2);
              }
            });
          } else {
            iterateObserversSafely(_this.observers, "next", result2);
          }
        }
      },
      error: onError
    }).catch(onError);
  };
  ObservableQuery2.prototype.tearDownQuery = function() {
    var queryManager = this.queryManager;
    this.isTornDown = true;
    queryManager.stopPollingQuery(this.queryId);
    this.subscriptions.forEach(function(sub) {
      return sub.unsubscribe();
    });
    this.subscriptions.clear();
    queryManager.removeObservableQuery(this.queryId);
    queryManager.stopQuery(this.queryId);
    this.observers.clear();
  };
  return ObservableQuery2;
}(Observable);
function defaultSubscriptionObserverErrorCallback(error) {
  invariant.error("Unhandled error", error.message, error.stack);
}
function iterateObserversSafely(observers, method, argument) {
  var observersWithMethod = [];
  observers.forEach(function(obs) {
    return obs[method] && observersWithMethod.push(obs);
  });
  observersWithMethod.forEach(function(obs) {
    return obs[method](argument);
  });
}
function assertNotCacheFirstOrOnly(obsQuery) {
  var fetchPolicy = obsQuery.options.fetchPolicy;
  false ? invariant(fetchPolicy !== "cache-first" && fetchPolicy !== "cache-only", 3) : invariant(fetchPolicy !== "cache-first" && fetchPolicy !== "cache-only", "Queries that specify the cache-first and cache-only fetchPolicies cannot also be polling queries.");
}
var MutationStore = function() {
  function MutationStore2() {
    this.store = {};
  }
  MutationStore2.prototype.getStore = function() {
    return this.store;
  };
  MutationStore2.prototype.get = function(mutationId) {
    return this.store[mutationId];
  };
  MutationStore2.prototype.initMutation = function(mutationId, mutation, variables) {
    this.store[mutationId] = {
      mutation,
      variables: variables || {},
      loading: true,
      error: null
    };
  };
  MutationStore2.prototype.markMutationError = function(mutationId, error) {
    var mutation = this.store[mutationId];
    if (mutation) {
      mutation.loading = false;
      mutation.error = error;
    }
  };
  MutationStore2.prototype.markMutationResult = function(mutationId) {
    var mutation = this.store[mutationId];
    if (mutation) {
      mutation.loading = false;
      mutation.error = null;
    }
  };
  MutationStore2.prototype.reset = function() {
    this.store = {};
  };
  return MutationStore2;
}();
var QueryStore = function() {
  function QueryStore2() {
    this.store = {};
  }
  QueryStore2.prototype.getStore = function() {
    return this.store;
  };
  QueryStore2.prototype.get = function(queryId) {
    return this.store[queryId];
  };
  QueryStore2.prototype.initQuery = function(query) {
    var previousQuery = this.store[query.queryId];
    false ? invariant(!previousQuery || previousQuery.document === query.document || equal(previousQuery.document, query.document), 19) : invariant(!previousQuery || previousQuery.document === query.document || equal(previousQuery.document, query.document), "Internal Error: may not update existing query string in store");
    var isSetVariables = false;
    var previousVariables = null;
    if (query.storePreviousVariables && previousQuery && previousQuery.networkStatus !== NetworkStatus.loading) {
      if (!equal(previousQuery.variables, query.variables)) {
        isSetVariables = true;
        previousVariables = previousQuery.variables;
      }
    }
    var networkStatus;
    if (isSetVariables) {
      networkStatus = NetworkStatus.setVariables;
    } else if (query.isPoll) {
      networkStatus = NetworkStatus.poll;
    } else if (query.isRefetch) {
      networkStatus = NetworkStatus.refetch;
    } else {
      networkStatus = NetworkStatus.loading;
    }
    var graphQLErrors = [];
    if (previousQuery && previousQuery.graphQLErrors) {
      graphQLErrors = previousQuery.graphQLErrors;
    }
    this.store[query.queryId] = {
      document: query.document,
      variables: query.variables,
      previousVariables,
      networkError: null,
      graphQLErrors,
      networkStatus,
      metadata: query.metadata
    };
    if (typeof query.fetchMoreForQueryId === "string" && this.store[query.fetchMoreForQueryId]) {
      this.store[query.fetchMoreForQueryId].networkStatus = NetworkStatus.fetchMore;
    }
  };
  QueryStore2.prototype.markQueryResult = function(queryId, result2, fetchMoreForQueryId) {
    if (!this.store || !this.store[queryId])
      return;
    this.store[queryId].networkError = null;
    this.store[queryId].graphQLErrors = isNonEmptyArray(result2.errors) ? result2.errors : [];
    this.store[queryId].previousVariables = null;
    this.store[queryId].networkStatus = NetworkStatus.ready;
    if (typeof fetchMoreForQueryId === "string" && this.store[fetchMoreForQueryId]) {
      this.store[fetchMoreForQueryId].networkStatus = NetworkStatus.ready;
    }
  };
  QueryStore2.prototype.markQueryError = function(queryId, error, fetchMoreForQueryId) {
    if (!this.store || !this.store[queryId])
      return;
    this.store[queryId].networkError = error;
    this.store[queryId].networkStatus = NetworkStatus.error;
    if (typeof fetchMoreForQueryId === "string") {
      this.markQueryResultClient(fetchMoreForQueryId, true);
    }
  };
  QueryStore2.prototype.markQueryResultClient = function(queryId, complete) {
    var storeValue = this.store && this.store[queryId];
    if (storeValue) {
      storeValue.networkError = null;
      storeValue.previousVariables = null;
      if (complete) {
        storeValue.networkStatus = NetworkStatus.ready;
      }
    }
  };
  QueryStore2.prototype.stopQuery = function(queryId) {
    delete this.store[queryId];
  };
  QueryStore2.prototype.reset = function(observableQueryIds) {
    var _this = this;
    Object.keys(this.store).forEach(function(queryId) {
      if (observableQueryIds.indexOf(queryId) < 0) {
        _this.stopQuery(queryId);
      } else {
        _this.store[queryId].networkStatus = NetworkStatus.loading;
      }
    });
  };
  return QueryStore2;
}();
function capitalizeFirstLetter(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
var LocalState = function() {
  function LocalState2(_a) {
    var cache = _a.cache, client = _a.client, resolvers = _a.resolvers, fragmentMatcher = _a.fragmentMatcher;
    this.cache = cache;
    if (client) {
      this.client = client;
    }
    if (resolvers) {
      this.addResolvers(resolvers);
    }
    if (fragmentMatcher) {
      this.setFragmentMatcher(fragmentMatcher);
    }
  }
  LocalState2.prototype.addResolvers = function(resolvers) {
    var _this = this;
    this.resolvers = this.resolvers || {};
    if (Array.isArray(resolvers)) {
      resolvers.forEach(function(resolverGroup) {
        _this.resolvers = mergeDeep(_this.resolvers, resolverGroup);
      });
    } else {
      this.resolvers = mergeDeep(this.resolvers, resolvers);
    }
  };
  LocalState2.prototype.setResolvers = function(resolvers) {
    this.resolvers = {};
    this.addResolvers(resolvers);
  };
  LocalState2.prototype.getResolvers = function() {
    return this.resolvers || {};
  };
  LocalState2.prototype.runResolvers = function(_a) {
    var document = _a.document, remoteResult = _a.remoteResult, context = _a.context, variables = _a.variables, _b = _a.onlyRunForcedResolvers, onlyRunForcedResolvers = _b === void 0 ? false : _b;
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(_c) {
        if (document) {
          return [2, this.resolveDocument(document, remoteResult.data, context, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function(localResult) {
            return __assign(__assign({}, remoteResult), { data: localResult.result });
          })];
        }
        return [2, remoteResult];
      });
    });
  };
  LocalState2.prototype.setFragmentMatcher = function(fragmentMatcher) {
    this.fragmentMatcher = fragmentMatcher;
  };
  LocalState2.prototype.getFragmentMatcher = function() {
    return this.fragmentMatcher;
  };
  LocalState2.prototype.clientQuery = function(document) {
    if (hasDirectives(["client"], document)) {
      if (this.resolvers) {
        return document;
      }
      invariant.warn("Found @client directives in a query but no ApolloClient resolvers were specified. This means ApolloClient local resolver handling has been disabled, and @client directives will be passed through to your link chain.");
    }
    return null;
  };
  LocalState2.prototype.serverQuery = function(document) {
    return this.resolvers ? removeClientSetsFromDocument(document) : document;
  };
  LocalState2.prototype.prepareContext = function(context) {
    if (context === void 0) {
      context = {};
    }
    var cache = this.cache;
    var newContext = __assign(__assign({}, context), { cache, getCacheKey: function(obj) {
      if (cache.config) {
        return cache.config.dataIdFromObject(obj);
      } else {
        false ? invariant(false, 6) : invariant(false, "To use context.getCacheKey, you need to use a cache that has a configurable dataIdFromObject, like apollo-cache-inmemory.");
      }
    } });
    return newContext;
  };
  LocalState2.prototype.addExportedVariables = function(document, variables, context) {
    if (variables === void 0) {
      variables = {};
    }
    if (context === void 0) {
      context = {};
    }
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(_a) {
        if (document) {
          return [2, this.resolveDocument(document, this.buildRootValueFromCache(document, variables) || {}, this.prepareContext(context), variables).then(function(data) {
            return __assign(__assign({}, variables), data.exportedVariables);
          })];
        }
        return [2, __assign({}, variables)];
      });
    });
  };
  LocalState2.prototype.shouldForceResolvers = function(document) {
    var forceResolvers = false;
    visit(document, {
      Directive: {
        enter: function(node) {
          if (node.name.value === "client" && node.arguments) {
            forceResolvers = node.arguments.some(function(arg) {
              return arg.name.value === "always" && arg.value.kind === "BooleanValue" && arg.value.value === true;
            });
            if (forceResolvers) {
              return BREAK;
            }
          }
        }
      }
    });
    return forceResolvers;
  };
  LocalState2.prototype.buildRootValueFromCache = function(document, variables) {
    return this.cache.diff({
      query: buildQueryFromSelectionSet(document),
      variables,
      returnPartialData: true,
      optimistic: false
    }).result;
  };
  LocalState2.prototype.resolveDocument = function(document, rootValue, context, variables, fragmentMatcher, onlyRunForcedResolvers) {
    if (context === void 0) {
      context = {};
    }
    if (variables === void 0) {
      variables = {};
    }
    if (fragmentMatcher === void 0) {
      fragmentMatcher = function() {
        return true;
      };
    }
    if (onlyRunForcedResolvers === void 0) {
      onlyRunForcedResolvers = false;
    }
    return __awaiter(this, void 0, void 0, function() {
      var mainDefinition, fragments, fragmentMap, definitionOperation, defaultOperationType, _a, cache, client, execContext;
      return __generator(this, function(_b) {
        mainDefinition = getMainDefinition(document);
        fragments = getFragmentDefinitions(document);
        fragmentMap = createFragmentMap(fragments);
        definitionOperation = mainDefinition.operation;
        defaultOperationType = definitionOperation ? capitalizeFirstLetter(definitionOperation) : "Query";
        _a = this, cache = _a.cache, client = _a.client;
        execContext = {
          fragmentMap,
          context: __assign(__assign({}, context), {
            cache,
            client
          }),
          variables,
          fragmentMatcher,
          defaultOperationType,
          exportedVariables: {},
          onlyRunForcedResolvers
        };
        return [2, this.resolveSelectionSet(mainDefinition.selectionSet, rootValue, execContext).then(function(result2) {
          return {
            result: result2,
            exportedVariables: execContext.exportedVariables
          };
        })];
      });
    });
  };
  LocalState2.prototype.resolveSelectionSet = function(selectionSet, rootValue, execContext) {
    return __awaiter(this, void 0, void 0, function() {
      var fragmentMap, context, variables, resultsToMerge, execute2;
      var _this = this;
      return __generator(this, function(_a) {
        fragmentMap = execContext.fragmentMap, context = execContext.context, variables = execContext.variables;
        resultsToMerge = [rootValue];
        execute2 = function(selection) {
          return __awaiter(_this, void 0, void 0, function() {
            var fragment, typeCondition;
            return __generator(this, function(_a2) {
              if (!shouldInclude(selection, variables)) {
                return [2];
              }
              if (isField(selection)) {
                return [2, this.resolveField(selection, rootValue, execContext).then(function(fieldResult) {
                  var _a3;
                  if (typeof fieldResult !== "undefined") {
                    resultsToMerge.push((_a3 = {}, _a3[resultKeyNameFromField(selection)] = fieldResult, _a3));
                  }
                })];
              }
              if (isInlineFragment(selection)) {
                fragment = selection;
              } else {
                fragment = fragmentMap[selection.name.value];
                false ? invariant(fragment, 7) : invariant(fragment, "No fragment named " + selection.name.value);
              }
              if (fragment && fragment.typeCondition) {
                typeCondition = fragment.typeCondition.name.value;
                if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {
                  return [2, this.resolveSelectionSet(fragment.selectionSet, rootValue, execContext).then(function(fragmentResult) {
                    resultsToMerge.push(fragmentResult);
                  })];
                }
              }
              return [2];
            });
          });
        };
        return [2, Promise.all(selectionSet.selections.map(execute2)).then(function() {
          return mergeDeepArray(resultsToMerge);
        })];
      });
    });
  };
  LocalState2.prototype.resolveField = function(field, rootValue, execContext) {
    return __awaiter(this, void 0, void 0, function() {
      var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;
      var _this = this;
      return __generator(this, function(_a) {
        variables = execContext.variables;
        fieldName = field.name.value;
        aliasedFieldName = resultKeyNameFromField(field);
        aliasUsed = fieldName !== aliasedFieldName;
        defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];
        resultPromise = Promise.resolve(defaultResult);
        if (!execContext.onlyRunForcedResolvers || this.shouldForceResolvers(field)) {
          resolverType = rootValue.__typename || execContext.defaultOperationType;
          resolverMap = this.resolvers && this.resolvers[resolverType];
          if (resolverMap) {
            resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];
            if (resolve) {
              resultPromise = Promise.resolve(resolve(rootValue, argumentsObjectFromField(field, variables), execContext.context, { field, fragmentMap: execContext.fragmentMap }));
            }
          }
        }
        return [2, resultPromise.then(function(result2) {
          if (result2 === void 0) {
            result2 = defaultResult;
          }
          if (field.directives) {
            field.directives.forEach(function(directive) {
              if (directive.name.value === "export" && directive.arguments) {
                directive.arguments.forEach(function(arg) {
                  if (arg.name.value === "as" && arg.value.kind === "StringValue") {
                    execContext.exportedVariables[arg.value.value] = result2;
                  }
                });
              }
            });
          }
          if (!field.selectionSet) {
            return result2;
          }
          if (result2 == null) {
            return result2;
          }
          if (Array.isArray(result2)) {
            return _this.resolveSubSelectedArray(field, result2, execContext);
          }
          if (field.selectionSet) {
            return _this.resolveSelectionSet(field.selectionSet, result2, execContext);
          }
        })];
      });
    });
  };
  LocalState2.prototype.resolveSubSelectedArray = function(field, result2, execContext) {
    var _this = this;
    return Promise.all(result2.map(function(item) {
      if (item === null) {
        return null;
      }
      if (Array.isArray(item)) {
        return _this.resolveSubSelectedArray(field, item, execContext);
      }
      if (field.selectionSet) {
        return _this.resolveSelectionSet(field.selectionSet, item, execContext);
      }
    }));
  };
  return LocalState2;
}();
function multiplex(inner) {
  var observers = /* @__PURE__ */ new Set();
  var sub = null;
  return new Observable(function(observer) {
    observers.add(observer);
    sub = sub || inner.subscribe({
      next: function(value) {
        observers.forEach(function(obs) {
          return obs.next && obs.next(value);
        });
      },
      error: function(error) {
        observers.forEach(function(obs) {
          return obs.error && obs.error(error);
        });
      },
      complete: function() {
        observers.forEach(function(obs) {
          return obs.complete && obs.complete();
        });
      }
    });
    return function() {
      if (observers.delete(observer) && !observers.size && sub) {
        sub.unsubscribe();
        sub = null;
      }
    };
  });
}
function asyncMap(observable, mapFn) {
  return new Observable(function(observer) {
    var next = observer.next, error = observer.error, complete = observer.complete;
    var activeNextCount = 0;
    var completed = false;
    var handler = {
      next: function(value) {
        ++activeNextCount;
        new Promise(function(resolve) {
          resolve(mapFn(value));
        }).then(function(result2) {
          --activeNextCount;
          next && next.call(observer, result2);
          completed && handler.complete();
        }, function(e) {
          --activeNextCount;
          error && error.call(observer, e);
        });
      },
      error: function(e) {
        error && error.call(observer, e);
      },
      complete: function() {
        completed = true;
        if (!activeNextCount) {
          complete && complete.call(observer);
        }
      }
    };
    var sub = observable.subscribe(handler);
    return function() {
      return sub.unsubscribe();
    };
  });
}
var hasOwnProperty = Object.prototype.hasOwnProperty;
var QueryManager = function() {
  function QueryManager2(_a) {
    var link = _a.link, _b = _a.queryDeduplication, queryDeduplication = _b === void 0 ? false : _b, store = _a.store, _c = _a.onBroadcast, onBroadcast = _c === void 0 ? function() {
      return void 0;
    } : _c, _d = _a.ssrMode, ssrMode = _d === void 0 ? false : _d, _e = _a.clientAwareness, clientAwareness = _e === void 0 ? {} : _e, localState = _a.localState, assumeImmutableResults = _a.assumeImmutableResults;
    this.mutationStore = new MutationStore();
    this.queryStore = new QueryStore();
    this.clientAwareness = {};
    this.idCounter = 1;
    this.queries = /* @__PURE__ */ new Map();
    this.fetchQueryRejectFns = /* @__PURE__ */ new Map();
    this.transformCache = new (canUseWeakMap ? WeakMap : Map)();
    this.inFlightLinkObservables = /* @__PURE__ */ new Map();
    this.pollingInfoByQueryId = /* @__PURE__ */ new Map();
    this.link = link;
    this.queryDeduplication = queryDeduplication;
    this.dataStore = store;
    this.onBroadcast = onBroadcast;
    this.clientAwareness = clientAwareness;
    this.localState = localState || new LocalState({ cache: store.getCache() });
    this.ssrMode = ssrMode;
    this.assumeImmutableResults = !!assumeImmutableResults;
  }
  QueryManager2.prototype.stop = function() {
    var _this = this;
    this.queries.forEach(function(_info, queryId) {
      _this.stopQueryNoBroadcast(queryId);
    });
    this.fetchQueryRejectFns.forEach(function(reject) {
      reject(false ? new InvariantError(8) : new InvariantError("QueryManager stopped while query was in flight"));
    });
  };
  QueryManager2.prototype.mutate = function(_a) {
    var mutation = _a.mutation, variables = _a.variables, optimisticResponse = _a.optimisticResponse, updateQueriesByName = _a.updateQueries, _b = _a.refetchQueries, refetchQueries = _b === void 0 ? [] : _b, _c = _a.awaitRefetchQueries, awaitRefetchQueries = _c === void 0 ? false : _c, updateWithProxyFn = _a.update, _d = _a.errorPolicy, errorPolicy = _d === void 0 ? "none" : _d, fetchPolicy = _a.fetchPolicy, _e = _a.context, context = _e === void 0 ? {} : _e;
    return __awaiter(this, void 0, void 0, function() {
      var mutationId, generateUpdateQueriesInfo, self2;
      var _this = this;
      return __generator(this, function(_f) {
        switch (_f.label) {
          case 0:
            false ? invariant(mutation, 9) : invariant(mutation, "mutation option is required. You must specify your GraphQL document in the mutation option.");
            false ? invariant(!fetchPolicy || fetchPolicy === "no-cache", 10) : invariant(!fetchPolicy || fetchPolicy === "no-cache", "Mutations only support a 'no-cache' fetchPolicy. If you don't want to disable the cache, remove your fetchPolicy setting to proceed with the default mutation behavior.");
            mutationId = this.generateQueryId();
            mutation = this.transform(mutation).document;
            this.setQuery(mutationId, function() {
              return { document: mutation };
            });
            variables = this.getVariables(mutation, variables);
            if (!this.transform(mutation).hasClientExports)
              return [3, 2];
            return [4, this.localState.addExportedVariables(mutation, variables, context)];
          case 1:
            variables = _f.sent();
            _f.label = 2;
          case 2:
            generateUpdateQueriesInfo = function() {
              var ret = {};
              if (updateQueriesByName) {
                _this.queries.forEach(function(_a2, queryId) {
                  var observableQuery = _a2.observableQuery;
                  if (observableQuery) {
                    var queryName = observableQuery.queryName;
                    if (queryName && hasOwnProperty.call(updateQueriesByName, queryName)) {
                      ret[queryId] = {
                        updater: updateQueriesByName[queryName],
                        query: _this.queryStore.get(queryId)
                      };
                    }
                  }
                });
              }
              return ret;
            };
            this.mutationStore.initMutation(mutationId, mutation, variables);
            this.dataStore.markMutationInit({
              mutationId,
              document: mutation,
              variables,
              updateQueries: generateUpdateQueriesInfo(),
              update: updateWithProxyFn,
              optimisticResponse
            });
            this.broadcastQueries();
            self2 = this;
            return [2, new Promise(function(resolve, reject) {
              var storeResult;
              var error;
              self2.getObservableFromLink(mutation, __assign(__assign({}, context), { optimisticResponse }), variables, false).subscribe({
                next: function(result2) {
                  if (graphQLResultHasError(result2) && errorPolicy === "none") {
                    error = new ApolloError({
                      graphQLErrors: result2.errors
                    });
                    return;
                  }
                  self2.mutationStore.markMutationResult(mutationId);
                  if (fetchPolicy !== "no-cache") {
                    self2.dataStore.markMutationResult({
                      mutationId,
                      result: result2,
                      document: mutation,
                      variables,
                      updateQueries: generateUpdateQueriesInfo(),
                      update: updateWithProxyFn
                    });
                  }
                  storeResult = result2;
                },
                error: function(err) {
                  self2.mutationStore.markMutationError(mutationId, err);
                  self2.dataStore.markMutationComplete({
                    mutationId,
                    optimisticResponse
                  });
                  self2.broadcastQueries();
                  self2.setQuery(mutationId, function() {
                    return { document: null };
                  });
                  reject(new ApolloError({
                    networkError: err
                  }));
                },
                complete: function() {
                  if (error) {
                    self2.mutationStore.markMutationError(mutationId, error);
                  }
                  self2.dataStore.markMutationComplete({
                    mutationId,
                    optimisticResponse
                  });
                  self2.broadcastQueries();
                  if (error) {
                    reject(error);
                    return;
                  }
                  if (typeof refetchQueries === "function") {
                    refetchQueries = refetchQueries(storeResult);
                  }
                  var refetchQueryPromises = [];
                  if (isNonEmptyArray(refetchQueries)) {
                    refetchQueries.forEach(function(refetchQuery) {
                      if (typeof refetchQuery === "string") {
                        self2.queries.forEach(function(_a2) {
                          var observableQuery = _a2.observableQuery;
                          if (observableQuery && observableQuery.queryName === refetchQuery) {
                            refetchQueryPromises.push(observableQuery.refetch());
                          }
                        });
                      } else {
                        var queryOptions = {
                          query: refetchQuery.query,
                          variables: refetchQuery.variables,
                          fetchPolicy: "network-only"
                        };
                        if (refetchQuery.context) {
                          queryOptions.context = refetchQuery.context;
                        }
                        refetchQueryPromises.push(self2.query(queryOptions));
                      }
                    });
                  }
                  Promise.all(awaitRefetchQueries ? refetchQueryPromises : []).then(function() {
                    self2.setQuery(mutationId, function() {
                      return { document: null };
                    });
                    if (errorPolicy === "ignore" && storeResult && graphQLResultHasError(storeResult)) {
                      delete storeResult.errors;
                    }
                    resolve(storeResult);
                  });
                }
              });
            })];
        }
      });
    });
  };
  QueryManager2.prototype.fetchQuery = function(queryId, options, fetchType, fetchMoreForQueryId) {
    return __awaiter(this, void 0, void 0, function() {
      var _a, metadata, _b, fetchPolicy, _c, context, query, variables, storeResult, isNetworkOnly, needToFetch, _d, complete, result2, shouldFetch, requestId, cancel, networkResult;
      var _this = this;
      return __generator(this, function(_e) {
        switch (_e.label) {
          case 0:
            _a = options.metadata, metadata = _a === void 0 ? null : _a, _b = options.fetchPolicy, fetchPolicy = _b === void 0 ? "cache-first" : _b, _c = options.context, context = _c === void 0 ? {} : _c;
            query = this.transform(options.query).document;
            variables = this.getVariables(query, options.variables);
            if (!this.transform(query).hasClientExports)
              return [3, 2];
            return [4, this.localState.addExportedVariables(query, variables, context)];
          case 1:
            variables = _e.sent();
            _e.label = 2;
          case 2:
            options = __assign(__assign({}, options), { variables });
            isNetworkOnly = fetchPolicy === "network-only" || fetchPolicy === "no-cache";
            needToFetch = isNetworkOnly;
            if (!isNetworkOnly) {
              _d = this.dataStore.getCache().diff({
                query,
                variables,
                returnPartialData: true,
                optimistic: false
              }), complete = _d.complete, result2 = _d.result;
              needToFetch = !complete || fetchPolicy === "cache-and-network";
              storeResult = result2;
            }
            shouldFetch = needToFetch && fetchPolicy !== "cache-only" && fetchPolicy !== "standby";
            if (hasDirectives(["live"], query))
              shouldFetch = true;
            requestId = this.idCounter++;
            cancel = fetchPolicy !== "no-cache" ? this.updateQueryWatch(queryId, query, options) : void 0;
            this.setQuery(queryId, function() {
              return {
                document: query,
                lastRequestId: requestId,
                invalidated: true,
                cancel
              };
            });
            this.invalidate(fetchMoreForQueryId);
            this.queryStore.initQuery({
              queryId,
              document: query,
              storePreviousVariables: shouldFetch,
              variables,
              isPoll: fetchType === FetchType.poll,
              isRefetch: fetchType === FetchType.refetch,
              metadata,
              fetchMoreForQueryId
            });
            this.broadcastQueries();
            if (shouldFetch) {
              networkResult = this.fetchRequest({
                requestId,
                queryId,
                document: query,
                options,
                fetchMoreForQueryId
              }).catch(function(error) {
                if (isApolloError(error)) {
                  throw error;
                } else {
                  if (requestId >= _this.getQuery(queryId).lastRequestId) {
                    _this.queryStore.markQueryError(queryId, error, fetchMoreForQueryId);
                    _this.invalidate(queryId);
                    _this.invalidate(fetchMoreForQueryId);
                    _this.broadcastQueries();
                  }
                  throw new ApolloError({ networkError: error });
                }
              });
              if (fetchPolicy !== "cache-and-network") {
                return [2, networkResult];
              }
              networkResult.catch(function() {
              });
            }
            this.queryStore.markQueryResultClient(queryId, !shouldFetch);
            this.invalidate(queryId);
            this.invalidate(fetchMoreForQueryId);
            if (this.transform(query).hasForcedResolvers) {
              return [2, this.localState.runResolvers({
                document: query,
                remoteResult: { data: storeResult },
                context,
                variables,
                onlyRunForcedResolvers: true
              }).then(function(result3) {
                _this.markQueryResult(queryId, result3, options, fetchMoreForQueryId);
                _this.broadcastQueries();
                return result3;
              })];
            }
            this.broadcastQueries();
            return [2, { data: storeResult }];
        }
      });
    });
  };
  QueryManager2.prototype.markQueryResult = function(queryId, result2, _a, fetchMoreForQueryId) {
    var fetchPolicy = _a.fetchPolicy, variables = _a.variables, errorPolicy = _a.errorPolicy;
    if (fetchPolicy === "no-cache") {
      this.setQuery(queryId, function() {
        return {
          newData: { result: result2.data, complete: true }
        };
      });
    } else {
      this.dataStore.markQueryResult(result2, this.getQuery(queryId).document, variables, fetchMoreForQueryId, errorPolicy === "ignore" || errorPolicy === "all");
    }
  };
  QueryManager2.prototype.queryListenerForObserver = function(queryId, options, observer) {
    var _this = this;
    function invoke(method, argument) {
      if (observer[method]) {
        try {
          observer[method](argument);
        } catch (e) {
          invariant.error(e);
        }
      } else if (method === "error") {
        invariant.error(argument);
      }
    }
    return function(queryStoreValue, newData) {
      _this.invalidate(queryId, false);
      if (!queryStoreValue)
        return;
      var _a = _this.getQuery(queryId), observableQuery = _a.observableQuery, document = _a.document;
      var fetchPolicy = observableQuery ? observableQuery.options.fetchPolicy : options.fetchPolicy;
      if (fetchPolicy === "standby")
        return;
      var loading = isNetworkRequestInFlight(queryStoreValue.networkStatus);
      var lastResult = observableQuery && observableQuery.getLastResult();
      var networkStatusChanged = !!(lastResult && lastResult.networkStatus !== queryStoreValue.networkStatus);
      var shouldNotifyIfLoading = options.returnPartialData || !newData && queryStoreValue.previousVariables || networkStatusChanged && options.notifyOnNetworkStatusChange || fetchPolicy === "cache-only" || fetchPolicy === "cache-and-network";
      if (loading && !shouldNotifyIfLoading) {
        return;
      }
      var hasGraphQLErrors = isNonEmptyArray(queryStoreValue.graphQLErrors);
      var errorPolicy = observableQuery && observableQuery.options.errorPolicy || options.errorPolicy || "none";
      if (errorPolicy === "none" && hasGraphQLErrors || queryStoreValue.networkError) {
        return invoke("error", new ApolloError({
          graphQLErrors: queryStoreValue.graphQLErrors,
          networkError: queryStoreValue.networkError
        }));
      }
      try {
        var data = void 0;
        var isMissing = void 0;
        if (newData) {
          if (fetchPolicy !== "no-cache" && fetchPolicy !== "network-only") {
            _this.setQuery(queryId, function() {
              return { newData: null };
            });
          }
          data = newData.result;
          isMissing = !newData.complete;
        } else {
          var lastError = observableQuery && observableQuery.getLastError();
          var errorStatusChanged = errorPolicy !== "none" && (lastError && lastError.graphQLErrors) !== queryStoreValue.graphQLErrors;
          if (lastResult && lastResult.data && !errorStatusChanged) {
            data = lastResult.data;
            isMissing = false;
          } else {
            var diffResult = _this.dataStore.getCache().diff({
              query: document,
              variables: queryStoreValue.previousVariables || queryStoreValue.variables,
              returnPartialData: true,
              optimistic: true
            });
            data = diffResult.result;
            isMissing = !diffResult.complete;
          }
        }
        var stale = isMissing && !(options.returnPartialData || fetchPolicy === "cache-only");
        var resultFromStore = {
          data: stale ? lastResult && lastResult.data : data,
          loading,
          networkStatus: queryStoreValue.networkStatus,
          stale
        };
        if (errorPolicy === "all" && hasGraphQLErrors) {
          resultFromStore.errors = queryStoreValue.graphQLErrors;
        }
        invoke("next", resultFromStore);
      } catch (networkError) {
        invoke("error", new ApolloError({ networkError }));
      }
    };
  };
  QueryManager2.prototype.transform = function(document) {
    var transformCache = this.transformCache;
    if (!transformCache.has(document)) {
      var cache = this.dataStore.getCache();
      var transformed = cache.transformDocument(document);
      var forLink = removeConnectionDirectiveFromDocument(cache.transformForLink(transformed));
      var clientQuery = this.localState.clientQuery(transformed);
      var serverQuery = this.localState.serverQuery(forLink);
      var cacheEntry_1 = {
        document: transformed,
        hasClientExports: hasClientExports(transformed),
        hasForcedResolvers: this.localState.shouldForceResolvers(transformed),
        clientQuery,
        serverQuery,
        defaultVars: getDefaultValues(getOperationDefinition(transformed))
      };
      var add = function(doc) {
        if (doc && !transformCache.has(doc)) {
          transformCache.set(doc, cacheEntry_1);
        }
      };
      add(document);
      add(transformed);
      add(clientQuery);
      add(serverQuery);
    }
    return transformCache.get(document);
  };
  QueryManager2.prototype.getVariables = function(document, variables) {
    return __assign(__assign({}, this.transform(document).defaultVars), variables);
  };
  QueryManager2.prototype.watchQuery = function(options, shouldSubscribe) {
    if (shouldSubscribe === void 0) {
      shouldSubscribe = true;
    }
    false ? invariant(options.fetchPolicy !== "standby", 11) : invariant(options.fetchPolicy !== "standby", 'client.watchQuery cannot be called with fetchPolicy set to "standby"');
    options.variables = this.getVariables(options.query, options.variables);
    if (typeof options.notifyOnNetworkStatusChange === "undefined") {
      options.notifyOnNetworkStatusChange = false;
    }
    var transformedOptions = __assign({}, options);
    return new ObservableQuery({
      queryManager: this,
      options: transformedOptions,
      shouldSubscribe
    });
  };
  QueryManager2.prototype.query = function(options) {
    var _this = this;
    false ? invariant(options.query, 12) : invariant(options.query, "query option is required. You must specify your GraphQL document in the query option.");
    false ? invariant(options.query.kind === "Document", 13) : invariant(options.query.kind === "Document", 'You must wrap the query string in a "gql" tag.');
    false ? invariant(!options.returnPartialData, 14) : invariant(!options.returnPartialData, "returnPartialData option only supported on watchQuery.");
    false ? invariant(!options.pollInterval, 15) : invariant(!options.pollInterval, "pollInterval option only supported on watchQuery.");
    return new Promise(function(resolve, reject) {
      var watchedQuery = _this.watchQuery(options, false);
      _this.fetchQueryRejectFns.set("query:" + watchedQuery.queryId, reject);
      watchedQuery.result().then(resolve, reject).then(function() {
        return _this.fetchQueryRejectFns.delete("query:" + watchedQuery.queryId);
      });
    });
  };
  QueryManager2.prototype.generateQueryId = function() {
    return String(this.idCounter++);
  };
  QueryManager2.prototype.stopQueryInStore = function(queryId) {
    this.stopQueryInStoreNoBroadcast(queryId);
    this.broadcastQueries();
  };
  QueryManager2.prototype.stopQueryInStoreNoBroadcast = function(queryId) {
    this.stopPollingQuery(queryId);
    this.queryStore.stopQuery(queryId);
    this.invalidate(queryId);
  };
  QueryManager2.prototype.addQueryListener = function(queryId, listener) {
    this.setQuery(queryId, function(_a) {
      var listeners = _a.listeners;
      listeners.add(listener);
      return { invalidated: false };
    });
  };
  QueryManager2.prototype.updateQueryWatch = function(queryId, document, options) {
    var _this = this;
    var cancel = this.getQuery(queryId).cancel;
    if (cancel)
      cancel();
    var previousResult = function() {
      var previousResult2 = null;
      var observableQuery = _this.getQuery(queryId).observableQuery;
      if (observableQuery) {
        var lastResult = observableQuery.getLastResult();
        if (lastResult) {
          previousResult2 = lastResult.data;
        }
      }
      return previousResult2;
    };
    return this.dataStore.getCache().watch({
      query: document,
      variables: options.variables,
      optimistic: true,
      previousResult,
      callback: function(newData) {
        _this.setQuery(queryId, function() {
          return { invalidated: true, newData };
        });
      }
    });
  };
  QueryManager2.prototype.addObservableQuery = function(queryId, observableQuery) {
    this.setQuery(queryId, function() {
      return { observableQuery };
    });
  };
  QueryManager2.prototype.removeObservableQuery = function(queryId) {
    var cancel = this.getQuery(queryId).cancel;
    this.setQuery(queryId, function() {
      return { observableQuery: null };
    });
    if (cancel)
      cancel();
  };
  QueryManager2.prototype.clearStore = function() {
    this.fetchQueryRejectFns.forEach(function(reject) {
      reject(false ? new InvariantError(16) : new InvariantError("Store reset while query was in flight (not completed in link chain)"));
    });
    var resetIds = [];
    this.queries.forEach(function(_a, queryId) {
      var observableQuery = _a.observableQuery;
      if (observableQuery)
        resetIds.push(queryId);
    });
    this.queryStore.reset(resetIds);
    this.mutationStore.reset();
    return this.dataStore.reset();
  };
  QueryManager2.prototype.resetStore = function() {
    var _this = this;
    return this.clearStore().then(function() {
      return _this.reFetchObservableQueries();
    });
  };
  QueryManager2.prototype.reFetchObservableQueries = function(includeStandby) {
    var _this = this;
    if (includeStandby === void 0) {
      includeStandby = false;
    }
    var observableQueryPromises = [];
    this.queries.forEach(function(_a, queryId) {
      var observableQuery = _a.observableQuery;
      if (observableQuery) {
        var fetchPolicy = observableQuery.options.fetchPolicy;
        observableQuery.resetLastResults();
        if (fetchPolicy !== "cache-only" && (includeStandby || fetchPolicy !== "standby")) {
          observableQueryPromises.push(observableQuery.refetch());
        }
        _this.setQuery(queryId, function() {
          return { newData: null };
        });
        _this.invalidate(queryId);
      }
    });
    this.broadcastQueries();
    return Promise.all(observableQueryPromises);
  };
  QueryManager2.prototype.observeQuery = function(queryId, options, observer) {
    this.addQueryListener(queryId, this.queryListenerForObserver(queryId, options, observer));
    return this.fetchQuery(queryId, options);
  };
  QueryManager2.prototype.startQuery = function(queryId, options, listener) {
    invariant.warn("The QueryManager.startQuery method has been deprecated");
    this.addQueryListener(queryId, listener);
    this.fetchQuery(queryId, options).catch(function() {
      return void 0;
    });
    return queryId;
  };
  QueryManager2.prototype.startGraphQLSubscription = function(_a) {
    var _this = this;
    var query = _a.query, fetchPolicy = _a.fetchPolicy, variables = _a.variables;
    query = this.transform(query).document;
    variables = this.getVariables(query, variables);
    var makeObservable = function(variables2) {
      return _this.getObservableFromLink(query, {}, variables2, false).map(function(result2) {
        if (!fetchPolicy || fetchPolicy !== "no-cache") {
          _this.dataStore.markSubscriptionResult(result2, query, variables2);
          _this.broadcastQueries();
        }
        if (graphQLResultHasError(result2)) {
          throw new ApolloError({
            graphQLErrors: result2.errors
          });
        }
        return result2;
      });
    };
    if (this.transform(query).hasClientExports) {
      var observablePromise_1 = this.localState.addExportedVariables(query, variables).then(makeObservable);
      return new Observable(function(observer) {
        var sub = null;
        observablePromise_1.then(function(observable) {
          return sub = observable.subscribe(observer);
        }, observer.error);
        return function() {
          return sub && sub.unsubscribe();
        };
      });
    }
    return makeObservable(variables);
  };
  QueryManager2.prototype.stopQuery = function(queryId) {
    this.stopQueryNoBroadcast(queryId);
    this.broadcastQueries();
  };
  QueryManager2.prototype.stopQueryNoBroadcast = function(queryId) {
    this.stopQueryInStoreNoBroadcast(queryId);
    this.removeQuery(queryId);
  };
  QueryManager2.prototype.removeQuery = function(queryId) {
    this.fetchQueryRejectFns.delete("query:" + queryId);
    this.fetchQueryRejectFns.delete("fetchRequest:" + queryId);
    this.getQuery(queryId).subscriptions.forEach(function(x) {
      return x.unsubscribe();
    });
    this.queries.delete(queryId);
  };
  QueryManager2.prototype.getCurrentQueryResult = function(observableQuery, optimistic) {
    if (optimistic === void 0) {
      optimistic = true;
    }
    var _a = observableQuery.options, variables = _a.variables, query = _a.query, fetchPolicy = _a.fetchPolicy, returnPartialData = _a.returnPartialData;
    var lastResult = observableQuery.getLastResult();
    var newData = this.getQuery(observableQuery.queryId).newData;
    if (newData && newData.complete) {
      return { data: newData.result, partial: false };
    }
    if (fetchPolicy === "no-cache" || fetchPolicy === "network-only") {
      return { data: void 0, partial: false };
    }
    var _b = this.dataStore.getCache().diff({
      query,
      variables,
      previousResult: lastResult ? lastResult.data : void 0,
      returnPartialData: true,
      optimistic
    }), result2 = _b.result, complete = _b.complete;
    return {
      data: complete || returnPartialData ? result2 : void 0,
      partial: !complete
    };
  };
  QueryManager2.prototype.getQueryWithPreviousResult = function(queryIdOrObservable) {
    var observableQuery;
    if (typeof queryIdOrObservable === "string") {
      var foundObserveableQuery = this.getQuery(queryIdOrObservable).observableQuery;
      false ? invariant(foundObserveableQuery, 17) : invariant(foundObserveableQuery, "ObservableQuery with this id doesn't exist: " + queryIdOrObservable);
      observableQuery = foundObserveableQuery;
    } else {
      observableQuery = queryIdOrObservable;
    }
    var _a = observableQuery.options, variables = _a.variables, query = _a.query;
    return {
      previousResult: this.getCurrentQueryResult(observableQuery, false).data,
      variables,
      document: query
    };
  };
  QueryManager2.prototype.broadcastQueries = function() {
    var _this = this;
    this.onBroadcast();
    this.queries.forEach(function(info, id) {
      if (info.invalidated) {
        info.listeners.forEach(function(listener) {
          if (listener) {
            listener(_this.queryStore.get(id), info.newData);
          }
        });
      }
    });
  };
  QueryManager2.prototype.getLocalState = function() {
    return this.localState;
  };
  QueryManager2.prototype.getObservableFromLink = function(query, context, variables, deduplication) {
    var _this = this;
    if (deduplication === void 0) {
      deduplication = this.queryDeduplication;
    }
    var observable;
    var serverQuery = this.transform(query).serverQuery;
    if (serverQuery) {
      var _a = this, inFlightLinkObservables_1 = _a.inFlightLinkObservables, link = _a.link;
      var operation = {
        query: serverQuery,
        variables,
        operationName: getOperationName(serverQuery) || void 0,
        context: this.prepareContext(__assign(__assign({}, context), { forceFetch: !deduplication }))
      };
      context = operation.context;
      if (deduplication) {
        var byVariables_1 = inFlightLinkObservables_1.get(serverQuery) || /* @__PURE__ */ new Map();
        inFlightLinkObservables_1.set(serverQuery, byVariables_1);
        var varJson_1 = JSON.stringify(variables);
        observable = byVariables_1.get(varJson_1);
        if (!observable) {
          byVariables_1.set(varJson_1, observable = multiplex(execute(link, operation)));
          var cleanup = function() {
            byVariables_1.delete(varJson_1);
            if (!byVariables_1.size)
              inFlightLinkObservables_1.delete(serverQuery);
            cleanupSub_1.unsubscribe();
          };
          var cleanupSub_1 = observable.subscribe({
            next: cleanup,
            error: cleanup,
            complete: cleanup
          });
        }
      } else {
        observable = multiplex(execute(link, operation));
      }
    } else {
      observable = Observable.of({ data: {} });
      context = this.prepareContext(context);
    }
    var clientQuery = this.transform(query).clientQuery;
    if (clientQuery) {
      observable = asyncMap(observable, function(result2) {
        return _this.localState.runResolvers({
          document: clientQuery,
          remoteResult: result2,
          context,
          variables
        });
      });
    }
    return observable;
  };
  QueryManager2.prototype.fetchRequest = function(_a) {
    var _this = this;
    var requestId = _a.requestId, queryId = _a.queryId, document = _a.document, options = _a.options, fetchMoreForQueryId = _a.fetchMoreForQueryId;
    var variables = options.variables, _b = options.errorPolicy, errorPolicy = _b === void 0 ? "none" : _b, fetchPolicy = options.fetchPolicy;
    var resultFromStore;
    var errorsFromStore;
    return new Promise(function(resolve, reject) {
      var observable = _this.getObservableFromLink(document, options.context, variables);
      var fqrfId = "fetchRequest:" + queryId;
      _this.fetchQueryRejectFns.set(fqrfId, reject);
      var cleanup = function() {
        _this.fetchQueryRejectFns.delete(fqrfId);
        _this.setQuery(queryId, function(_a2) {
          var subscriptions = _a2.subscriptions;
          subscriptions.delete(subscription);
        });
      };
      var subscription = observable.map(function(result2) {
        if (requestId >= _this.getQuery(queryId).lastRequestId) {
          _this.markQueryResult(queryId, result2, options, fetchMoreForQueryId);
          _this.queryStore.markQueryResult(queryId, result2, fetchMoreForQueryId);
          _this.invalidate(queryId);
          _this.invalidate(fetchMoreForQueryId);
          _this.broadcastQueries();
        }
        if (errorPolicy === "none" && isNonEmptyArray(result2.errors)) {
          return reject(new ApolloError({
            graphQLErrors: result2.errors
          }));
        }
        if (errorPolicy === "all") {
          errorsFromStore = result2.errors;
        }
        if (fetchMoreForQueryId || fetchPolicy === "no-cache") {
          resultFromStore = result2.data;
        } else {
          var _a2 = _this.dataStore.getCache().diff({
            variables,
            query: document,
            optimistic: false,
            returnPartialData: true
          }), result_1 = _a2.result, complete = _a2.complete;
          if (complete || options.returnPartialData) {
            resultFromStore = result_1;
          }
        }
      }).subscribe({
        error: function(error) {
          cleanup();
          reject(error);
        },
        complete: function() {
          cleanup();
          resolve({
            data: resultFromStore,
            errors: errorsFromStore,
            loading: false,
            networkStatus: NetworkStatus.ready,
            stale: false
          });
        }
      });
      _this.setQuery(queryId, function(_a2) {
        var subscriptions = _a2.subscriptions;
        subscriptions.add(subscription);
      });
    });
  };
  QueryManager2.prototype.getQuery = function(queryId) {
    return this.queries.get(queryId) || {
      listeners: /* @__PURE__ */ new Set(),
      invalidated: false,
      document: null,
      newData: null,
      lastRequestId: 1,
      observableQuery: null,
      subscriptions: /* @__PURE__ */ new Set()
    };
  };
  QueryManager2.prototype.setQuery = function(queryId, updater) {
    var prev = this.getQuery(queryId);
    var newInfo = __assign(__assign({}, prev), updater(prev));
    this.queries.set(queryId, newInfo);
  };
  QueryManager2.prototype.invalidate = function(queryId, invalidated) {
    if (invalidated === void 0) {
      invalidated = true;
    }
    if (queryId) {
      this.setQuery(queryId, function() {
        return { invalidated };
      });
    }
  };
  QueryManager2.prototype.prepareContext = function(context) {
    if (context === void 0) {
      context = {};
    }
    var newContext = this.localState.prepareContext(context);
    return __assign(__assign({}, newContext), { clientAwareness: this.clientAwareness });
  };
  QueryManager2.prototype.checkInFlight = function(queryId) {
    var query = this.queryStore.get(queryId);
    return query && query.networkStatus !== NetworkStatus.ready && query.networkStatus !== NetworkStatus.error;
  };
  QueryManager2.prototype.startPollingQuery = function(options, queryId, listener) {
    var _this = this;
    var pollInterval = options.pollInterval;
    false ? invariant(pollInterval, 18) : invariant(pollInterval, "Attempted to start a polling query without a polling interval.");
    if (!this.ssrMode) {
      var info = this.pollingInfoByQueryId.get(queryId);
      if (!info) {
        this.pollingInfoByQueryId.set(queryId, info = {});
      }
      info.interval = pollInterval;
      info.options = __assign(__assign({}, options), { fetchPolicy: "network-only" });
      var maybeFetch_1 = function() {
        var info2 = _this.pollingInfoByQueryId.get(queryId);
        if (info2) {
          if (_this.checkInFlight(queryId)) {
            poll_1();
          } else {
            _this.fetchQuery(queryId, info2.options, FetchType.poll).then(poll_1, poll_1);
          }
        }
      };
      var poll_1 = function() {
        var info2 = _this.pollingInfoByQueryId.get(queryId);
        if (info2) {
          clearTimeout(info2.timeout);
          info2.timeout = setTimeout(maybeFetch_1, info2.interval);
        }
      };
      if (listener) {
        this.addQueryListener(queryId, listener);
      }
      poll_1();
    }
    return queryId;
  };
  QueryManager2.prototype.stopPollingQuery = function(queryId) {
    this.pollingInfoByQueryId.delete(queryId);
  };
  return QueryManager2;
}();
var DataStore = function() {
  function DataStore2(initialCache) {
    this.cache = initialCache;
  }
  DataStore2.prototype.getCache = function() {
    return this.cache;
  };
  DataStore2.prototype.markQueryResult = function(result2, document, variables, fetchMoreForQueryId, ignoreErrors) {
    if (ignoreErrors === void 0) {
      ignoreErrors = false;
    }
    var writeWithErrors = !graphQLResultHasError(result2);
    if (ignoreErrors && graphQLResultHasError(result2) && result2.data) {
      writeWithErrors = true;
    }
    if (!fetchMoreForQueryId && writeWithErrors) {
      this.cache.write({
        result: result2.data,
        dataId: "ROOT_QUERY",
        query: document,
        variables
      });
    }
  };
  DataStore2.prototype.markSubscriptionResult = function(result2, document, variables) {
    if (!graphQLResultHasError(result2)) {
      this.cache.write({
        result: result2.data,
        dataId: "ROOT_SUBSCRIPTION",
        query: document,
        variables
      });
    }
  };
  DataStore2.prototype.markMutationInit = function(mutation) {
    var _this = this;
    if (mutation.optimisticResponse) {
      var optimistic_1;
      if (typeof mutation.optimisticResponse === "function") {
        optimistic_1 = mutation.optimisticResponse(mutation.variables);
      } else {
        optimistic_1 = mutation.optimisticResponse;
      }
      this.cache.recordOptimisticTransaction(function(c) {
        var orig = _this.cache;
        _this.cache = c;
        try {
          _this.markMutationResult({
            mutationId: mutation.mutationId,
            result: { data: optimistic_1 },
            document: mutation.document,
            variables: mutation.variables,
            updateQueries: mutation.updateQueries,
            update: mutation.update
          });
        } finally {
          _this.cache = orig;
        }
      }, mutation.mutationId);
    }
  };
  DataStore2.prototype.markMutationResult = function(mutation) {
    var _this = this;
    if (!graphQLResultHasError(mutation.result)) {
      var cacheWrites_1 = [{
        result: mutation.result.data,
        dataId: "ROOT_MUTATION",
        query: mutation.document,
        variables: mutation.variables
      }];
      var updateQueries_1 = mutation.updateQueries;
      if (updateQueries_1) {
        Object.keys(updateQueries_1).forEach(function(id) {
          var _a = updateQueries_1[id], query = _a.query, updater = _a.updater;
          var _b = _this.cache.diff({
            query: query.document,
            variables: query.variables,
            returnPartialData: true,
            optimistic: false
          }), currentQueryResult = _b.result, complete = _b.complete;
          if (complete) {
            var nextQueryResult = tryFunctionOrLogError(function() {
              return updater(currentQueryResult, {
                mutationResult: mutation.result,
                queryName: getOperationName(query.document) || void 0,
                queryVariables: query.variables
              });
            });
            if (nextQueryResult) {
              cacheWrites_1.push({
                result: nextQueryResult,
                dataId: "ROOT_QUERY",
                query: query.document,
                variables: query.variables
              });
            }
          }
        });
      }
      this.cache.performTransaction(function(c) {
        cacheWrites_1.forEach(function(write) {
          return c.write(write);
        });
        var update = mutation.update;
        if (update) {
          tryFunctionOrLogError(function() {
            return update(c, mutation.result);
          });
        }
      });
    }
  };
  DataStore2.prototype.markMutationComplete = function(_a) {
    var mutationId = _a.mutationId, optimisticResponse = _a.optimisticResponse;
    if (optimisticResponse) {
      this.cache.removeOptimistic(mutationId);
    }
  };
  DataStore2.prototype.markUpdateQueryResult = function(document, variables, newResult) {
    this.cache.write({
      result: newResult,
      dataId: "ROOT_QUERY",
      variables,
      query: document
    });
  };
  DataStore2.prototype.reset = function() {
    return this.cache.reset();
  };
  return DataStore2;
}();
var version = "2.6.10";
var hasSuggestedDevtools = false;
var ApolloClient = function() {
  function ApolloClient2(options) {
    var _this = this;
    this.defaultOptions = {};
    this.resetStoreCallbacks = [];
    this.clearStoreCallbacks = [];
    var cache = options.cache, _a = options.ssrMode, ssrMode = _a === void 0 ? false : _a, _b = options.ssrForceFetchDelay, ssrForceFetchDelay = _b === void 0 ? 0 : _b, connectToDevTools = options.connectToDevTools, _c = options.queryDeduplication, queryDeduplication = _c === void 0 ? true : _c, defaultOptions = options.defaultOptions, _d = options.assumeImmutableResults, assumeImmutableResults = _d === void 0 ? false : _d, resolvers = options.resolvers, typeDefs = options.typeDefs, fragmentMatcher = options.fragmentMatcher, clientAwarenessName = options.name, clientAwarenessVersion = options.version;
    var link = options.link;
    if (!link && resolvers) {
      link = ApolloLink.empty();
    }
    if (!link || !cache) {
      throw false ? new InvariantError(4) : new InvariantError("In order to initialize Apollo Client, you must specify 'link' and 'cache' properties in the options object.\nThese options are part of the upgrade requirements when migrating from Apollo Client 1.x to Apollo Client 2.x.\nFor more information, please visit: https://www.apollographql.com/docs/tutorial/client.html#apollo-client-setup");
    }
    this.link = link;
    this.cache = cache;
    this.store = new DataStore(cache);
    this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;
    this.queryDeduplication = queryDeduplication;
    this.defaultOptions = defaultOptions || {};
    this.typeDefs = typeDefs;
    if (ssrForceFetchDelay) {
      setTimeout(function() {
        return _this.disableNetworkFetches = false;
      }, ssrForceFetchDelay);
    }
    this.watchQuery = this.watchQuery.bind(this);
    this.query = this.query.bind(this);
    this.mutate = this.mutate.bind(this);
    this.resetStore = this.resetStore.bind(this);
    this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);
    var defaultConnectToDevTools = typeof window !== "undefined" && !window.__APOLLO_CLIENT__;
    if (typeof connectToDevTools === "undefined" ? defaultConnectToDevTools : connectToDevTools && typeof window !== "undefined") {
      window.__APOLLO_CLIENT__ = this;
    }
    if (!hasSuggestedDevtools && true) {
      hasSuggestedDevtools = true;
      if (typeof window !== "undefined" && window.document && window.top === window.self) {
        if (typeof window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
          if (window.navigator && window.navigator.userAgent && window.navigator.userAgent.indexOf("Chrome") > -1) {
            console.debug("Download the Apollo DevTools for a better development experience: https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm");
          }
        }
      }
    }
    this.version = version;
    this.localState = new LocalState({
      cache,
      client: this,
      resolvers,
      fragmentMatcher
    });
    this.queryManager = new QueryManager({
      link: this.link,
      store: this.store,
      queryDeduplication,
      ssrMode,
      clientAwareness: {
        name: clientAwarenessName,
        version: clientAwarenessVersion
      },
      localState: this.localState,
      assumeImmutableResults,
      onBroadcast: function() {
        if (_this.devToolsHookCb) {
          _this.devToolsHookCb({
            action: {},
            state: {
              queries: _this.queryManager.queryStore.getStore(),
              mutations: _this.queryManager.mutationStore.getStore()
            },
            dataWithOptimisticResults: _this.cache.extract(true)
          });
        }
      }
    });
  }
  ApolloClient2.prototype.stop = function() {
    this.queryManager.stop();
  };
  ApolloClient2.prototype.watchQuery = function(options) {
    if (this.defaultOptions.watchQuery) {
      options = __assign(__assign({}, this.defaultOptions.watchQuery), options);
    }
    if (this.disableNetworkFetches && (options.fetchPolicy === "network-only" || options.fetchPolicy === "cache-and-network")) {
      options = __assign(__assign({}, options), { fetchPolicy: "cache-first" });
    }
    return this.queryManager.watchQuery(options);
  };
  ApolloClient2.prototype.query = function(options) {
    if (this.defaultOptions.query) {
      options = __assign(__assign({}, this.defaultOptions.query), options);
    }
    false ? invariant(options.fetchPolicy !== "cache-and-network", 5) : invariant(options.fetchPolicy !== "cache-and-network", "The cache-and-network fetchPolicy does not work with client.query, because client.query can only return a single result. Please use client.watchQuery to receive multiple results from the cache and the network, or consider using a different fetchPolicy, such as cache-first or network-only.");
    if (this.disableNetworkFetches && options.fetchPolicy === "network-only") {
      options = __assign(__assign({}, options), { fetchPolicy: "cache-first" });
    }
    return this.queryManager.query(options);
  };
  ApolloClient2.prototype.mutate = function(options) {
    if (this.defaultOptions.mutate) {
      options = __assign(__assign({}, this.defaultOptions.mutate), options);
    }
    return this.queryManager.mutate(options);
  };
  ApolloClient2.prototype.subscribe = function(options) {
    return this.queryManager.startGraphQLSubscription(options);
  };
  ApolloClient2.prototype.readQuery = function(options, optimistic) {
    if (optimistic === void 0) {
      optimistic = false;
    }
    return this.cache.readQuery(options, optimistic);
  };
  ApolloClient2.prototype.readFragment = function(options, optimistic) {
    if (optimistic === void 0) {
      optimistic = false;
    }
    return this.cache.readFragment(options, optimistic);
  };
  ApolloClient2.prototype.writeQuery = function(options) {
    var result2 = this.cache.writeQuery(options);
    this.queryManager.broadcastQueries();
    return result2;
  };
  ApolloClient2.prototype.writeFragment = function(options) {
    var result2 = this.cache.writeFragment(options);
    this.queryManager.broadcastQueries();
    return result2;
  };
  ApolloClient2.prototype.writeData = function(options) {
    var result2 = this.cache.writeData(options);
    this.queryManager.broadcastQueries();
    return result2;
  };
  ApolloClient2.prototype.__actionHookForDevTools = function(cb) {
    this.devToolsHookCb = cb;
  };
  ApolloClient2.prototype.__requestRaw = function(payload) {
    return execute(this.link, payload);
  };
  ApolloClient2.prototype.initQueryManager = function() {
    invariant.warn("Calling the initQueryManager method is no longer necessary, and it will be removed from ApolloClient in version 3.0.");
    return this.queryManager;
  };
  ApolloClient2.prototype.resetStore = function() {
    var _this = this;
    return Promise.resolve().then(function() {
      return _this.queryManager.clearStore();
    }).then(function() {
      return Promise.all(_this.resetStoreCallbacks.map(function(fn) {
        return fn();
      }));
    }).then(function() {
      return _this.reFetchObservableQueries();
    });
  };
  ApolloClient2.prototype.clearStore = function() {
    var _this = this;
    return Promise.resolve().then(function() {
      return _this.queryManager.clearStore();
    }).then(function() {
      return Promise.all(_this.clearStoreCallbacks.map(function(fn) {
        return fn();
      }));
    });
  };
  ApolloClient2.prototype.onResetStore = function(cb) {
    var _this = this;
    this.resetStoreCallbacks.push(cb);
    return function() {
      _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function(c) {
        return c !== cb;
      });
    };
  };
  ApolloClient2.prototype.onClearStore = function(cb) {
    var _this = this;
    this.clearStoreCallbacks.push(cb);
    return function() {
      _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function(c) {
        return c !== cb;
      });
    };
  };
  ApolloClient2.prototype.reFetchObservableQueries = function(includeStandby) {
    return this.queryManager.reFetchObservableQueries(includeStandby);
  };
  ApolloClient2.prototype.extract = function(optimistic) {
    return this.cache.extract(optimistic);
  };
  ApolloClient2.prototype.restore = function(serializedState) {
    return this.cache.restore(serializedState);
  };
  ApolloClient2.prototype.addResolvers = function(resolvers) {
    this.localState.addResolvers(resolvers);
  };
  ApolloClient2.prototype.setResolvers = function(resolvers) {
    this.localState.setResolvers(resolvers);
  };
  ApolloClient2.prototype.getResolvers = function() {
    return this.localState.getResolvers();
  };
  ApolloClient2.prototype.setLocalStateFragmentMatcher = function(fragmentMatcher) {
    this.localState.setFragmentMatcher(fragmentMatcher);
  };
  return ApolloClient2;
}();
var bundle_esm_default2 = ApolloClient;

// dep:apollo-client
var apollo_client_default = bundle_esm_default2;
export {
  ApolloClient,
  ApolloError,
  FetchType,
  NetworkStatus,
  ObservableQuery,
  apollo_client_default as default,
  isApolloError
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
//# sourceMappingURL=apollo-client.js.map
