import {
  InvariantError,
  addTypenameToDocument,
  argumentsObjectFromField,
  assign,
  canUseWeakMap,
  createFragmentMap,
  equal,
  getDefaultValues,
  getDirectiveInfoFromField,
  getFragmentDefinitions,
  getFragmentQueryDocument,
  getMainDefinition,
  getOperationDefinition,
  getQueryDefinition,
  getStoreKeyName,
  invariant,
  isField,
  isIdValue,
  isInlineFragment,
  isJsonValue,
  isProduction,
  isTest,
  maybeDeepFreeze,
  mergeDeepArray,
  resultKeyNameFromField,
  shouldInclude,
  storeKeyNameFromField,
  toIdValue
} from "./chunk-ZCMRSXYQ.js";
import "./chunk-TGUKOLNW.js";
import "./chunk-TWLJ45QX.js";

// node_modules/apollo-cache-inmemory/node_modules/tslib/tslib.es6.js
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (b2.hasOwnProperty(p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};

// node_modules/apollo-cache/lib/bundle.esm.js
function queryFromPojo(obj) {
  var op = {
    kind: "OperationDefinition",
    operation: "query",
    name: {
      kind: "Name",
      value: "GeneratedClientQuery"
    },
    selectionSet: selectionSetFromObj(obj)
  };
  var out = {
    kind: "Document",
    definitions: [op]
  };
  return out;
}
function fragmentFromPojo(obj, typename) {
  var frag = {
    kind: "FragmentDefinition",
    typeCondition: {
      kind: "NamedType",
      name: {
        kind: "Name",
        value: typename || "__FakeType"
      }
    },
    name: {
      kind: "Name",
      value: "GeneratedClientQuery"
    },
    selectionSet: selectionSetFromObj(obj)
  };
  var out = {
    kind: "Document",
    definitions: [frag]
  };
  return out;
}
function selectionSetFromObj(obj) {
  if (typeof obj === "number" || typeof obj === "boolean" || typeof obj === "string" || typeof obj === "undefined" || obj === null) {
    return null;
  }
  if (Array.isArray(obj)) {
    return selectionSetFromObj(obj[0]);
  }
  var selections = [];
  Object.keys(obj).forEach(function(key) {
    var nestedSelSet = selectionSetFromObj(obj[key]);
    var field = {
      kind: "Field",
      name: {
        kind: "Name",
        value: key
      },
      selectionSet: nestedSelSet || void 0
    };
    selections.push(field);
  });
  var selectionSet = {
    kind: "SelectionSet",
    selections
  };
  return selectionSet;
}
var justTypenameQuery = {
  kind: "Document",
  definitions: [
    {
      kind: "OperationDefinition",
      operation: "query",
      name: null,
      variableDefinitions: null,
      directives: [],
      selectionSet: {
        kind: "SelectionSet",
        selections: [
          {
            kind: "Field",
            alias: null,
            name: {
              kind: "Name",
              value: "__typename"
            },
            arguments: [],
            directives: [],
            selectionSet: null
          }
        ]
      }
    }
  ]
};
var ApolloCache = function() {
  function ApolloCache2() {
  }
  ApolloCache2.prototype.transformDocument = function(document) {
    return document;
  };
  ApolloCache2.prototype.transformForLink = function(document) {
    return document;
  };
  ApolloCache2.prototype.readQuery = function(options, optimistic) {
    if (optimistic === void 0) {
      optimistic = false;
    }
    return this.read({
      query: options.query,
      variables: options.variables,
      optimistic
    });
  };
  ApolloCache2.prototype.readFragment = function(options, optimistic) {
    if (optimistic === void 0) {
      optimistic = false;
    }
    return this.read({
      query: getFragmentQueryDocument(options.fragment, options.fragmentName),
      variables: options.variables,
      rootId: options.id,
      optimistic
    });
  };
  ApolloCache2.prototype.writeQuery = function(options) {
    this.write({
      dataId: "ROOT_QUERY",
      result: options.data,
      query: options.query,
      variables: options.variables
    });
  };
  ApolloCache2.prototype.writeFragment = function(options) {
    this.write({
      dataId: options.id,
      result: options.data,
      variables: options.variables,
      query: getFragmentQueryDocument(options.fragment, options.fragmentName)
    });
  };
  ApolloCache2.prototype.writeData = function(_a) {
    var id = _a.id, data = _a.data;
    if (typeof id !== "undefined") {
      var typenameResult = null;
      try {
        typenameResult = this.read({
          rootId: id,
          optimistic: false,
          query: justTypenameQuery
        });
      } catch (e) {
      }
      var __typename = typenameResult && typenameResult.__typename || "__ClientData";
      var dataToWrite = Object.assign({ __typename }, data);
      this.writeFragment({
        id,
        fragment: fragmentFromPojo(dataToWrite, __typename),
        data: dataToWrite
      });
    } else {
      this.writeQuery({ query: queryFromPojo(data), data });
    }
  };
  return ApolloCache2;
}();
var Cache;
(function(Cache3) {
})(Cache || (Cache = {}));

// node_modules/@wry/context/lib/context.esm.js
var currentContext = null;
var MISSING_VALUE = {};
var idCounter = 1;
var makeSlotClass = function() {
  return function() {
    function Slot2() {
      this.id = [
        "slot",
        idCounter++,
        Date.now(),
        Math.random().toString(36).slice(2)
      ].join(":");
    }
    Slot2.prototype.hasValue = function() {
      for (var context_1 = currentContext; context_1; context_1 = context_1.parent) {
        if (this.id in context_1.slots) {
          var value = context_1.slots[this.id];
          if (value === MISSING_VALUE)
            break;
          if (context_1 !== currentContext) {
            currentContext.slots[this.id] = value;
          }
          return true;
        }
      }
      if (currentContext) {
        currentContext.slots[this.id] = MISSING_VALUE;
      }
      return false;
    };
    Slot2.prototype.getValue = function() {
      if (this.hasValue()) {
        return currentContext.slots[this.id];
      }
    };
    Slot2.prototype.withValue = function(value, callback, args, thisArg) {
      var _a;
      var slots = (_a = {
        __proto__: null
      }, _a[this.id] = value, _a);
      var parent = currentContext;
      currentContext = { parent, slots };
      try {
        return callback.apply(thisArg, args);
      } finally {
        currentContext = parent;
      }
    };
    Slot2.bind = function(callback) {
      var context = currentContext;
      return function() {
        var saved = currentContext;
        try {
          currentContext = context;
          return callback.apply(this, arguments);
        } finally {
          currentContext = saved;
        }
      };
    };
    Slot2.noContext = function(callback, args, thisArg) {
      if (currentContext) {
        var saved = currentContext;
        try {
          currentContext = null;
          return callback.apply(thisArg, args);
        } finally {
          currentContext = saved;
        }
      } else {
        return callback.apply(thisArg, args);
      }
    };
    return Slot2;
  }();
};
var globalKey = "@wry/context:Slot";
var host = Array;
var Slot = host[globalKey] || function() {
  var Slot2 = makeSlotClass();
  try {
    Object.defineProperty(host, globalKey, {
      value: host[globalKey] = Slot2,
      enumerable: false,
      writable: false,
      configurable: false
    });
  } finally {
    return Slot2;
  }
}();
var bind = Slot.bind;
var noContext = Slot.noContext;

// node_modules/optimism/lib/bundle.esm.js
function defaultDispose() {
}
var Cache2 = function() {
  function Cache3(max, dispose) {
    if (max === void 0) {
      max = Infinity;
    }
    if (dispose === void 0) {
      dispose = defaultDispose;
    }
    this.max = max;
    this.dispose = dispose;
    this.map = /* @__PURE__ */ new Map();
    this.newest = null;
    this.oldest = null;
  }
  Cache3.prototype.has = function(key) {
    return this.map.has(key);
  };
  Cache3.prototype.get = function(key) {
    var entry = this.getEntry(key);
    return entry && entry.value;
  };
  Cache3.prototype.getEntry = function(key) {
    var entry = this.map.get(key);
    if (entry && entry !== this.newest) {
      var older = entry.older, newer = entry.newer;
      if (newer) {
        newer.older = older;
      }
      if (older) {
        older.newer = newer;
      }
      entry.older = this.newest;
      entry.older.newer = entry;
      entry.newer = null;
      this.newest = entry;
      if (entry === this.oldest) {
        this.oldest = newer;
      }
    }
    return entry;
  };
  Cache3.prototype.set = function(key, value) {
    var entry = this.getEntry(key);
    if (entry) {
      return entry.value = value;
    }
    entry = {
      key,
      value,
      newer: null,
      older: this.newest
    };
    if (this.newest) {
      this.newest.newer = entry;
    }
    this.newest = entry;
    this.oldest = this.oldest || entry;
    this.map.set(key, entry);
    return entry.value;
  };
  Cache3.prototype.clean = function() {
    while (this.oldest && this.map.size > this.max) {
      this.delete(this.oldest.key);
    }
  };
  Cache3.prototype.delete = function(key) {
    var entry = this.map.get(key);
    if (entry) {
      if (entry === this.newest) {
        this.newest = entry.older;
      }
      if (entry === this.oldest) {
        this.oldest = entry.newer;
      }
      if (entry.newer) {
        entry.newer.older = entry.older;
      }
      if (entry.older) {
        entry.older.newer = entry.newer;
      }
      this.map.delete(key);
      this.dispose(entry.value, key);
      return true;
    }
    return false;
  };
  return Cache3;
}();
var parentEntrySlot = new Slot();
var reusableEmptyArray = [];
var emptySetPool = [];
var POOL_TARGET_SIZE = 100;
function assert(condition, optionalMessage) {
  if (!condition) {
    throw new Error(optionalMessage || "assertion failure");
  }
}
function valueIs(a, b) {
  var len = a.length;
  return len > 0 && len === b.length && a[len - 1] === b[len - 1];
}
function valueGet(value) {
  switch (value.length) {
    case 0:
      throw new Error("unknown value");
    case 1:
      return value[0];
    case 2:
      throw value[1];
  }
}
function valueCopy(value) {
  return value.slice(0);
}
var Entry = function() {
  function Entry2(fn, args) {
    this.fn = fn;
    this.args = args;
    this.parents = /* @__PURE__ */ new Set();
    this.childValues = /* @__PURE__ */ new Map();
    this.dirtyChildren = null;
    this.dirty = true;
    this.recomputing = false;
    this.value = [];
    ++Entry2.count;
  }
  Entry2.prototype.recompute = function() {
    assert(!this.recomputing, "already recomputing");
    if (!rememberParent(this) && maybeReportOrphan(this)) {
      return void 0;
    }
    return mightBeDirty(this) ? reallyRecompute(this) : valueGet(this.value);
  };
  Entry2.prototype.setDirty = function() {
    if (this.dirty)
      return;
    this.dirty = true;
    this.value.length = 0;
    reportDirty(this);
    maybeUnsubscribe(this);
  };
  Entry2.prototype.dispose = function() {
    var _this = this;
    forgetChildren(this).forEach(maybeReportOrphan);
    maybeUnsubscribe(this);
    this.parents.forEach(function(parent) {
      parent.setDirty();
      forgetChild(parent, _this);
    });
  };
  Entry2.count = 0;
  return Entry2;
}();
function rememberParent(child) {
  var parent = parentEntrySlot.getValue();
  if (parent) {
    child.parents.add(parent);
    if (!parent.childValues.has(child)) {
      parent.childValues.set(child, []);
    }
    if (mightBeDirty(child)) {
      reportDirtyChild(parent, child);
    } else {
      reportCleanChild(parent, child);
    }
    return parent;
  }
}
function reallyRecompute(entry) {
  var originalChildren = forgetChildren(entry);
  parentEntrySlot.withValue(entry, recomputeNewValue, [entry]);
  if (maybeSubscribe(entry)) {
    setClean(entry);
  }
  originalChildren.forEach(maybeReportOrphan);
  return valueGet(entry.value);
}
function recomputeNewValue(entry) {
  entry.recomputing = true;
  entry.value.length = 0;
  try {
    entry.value[0] = entry.fn.apply(null, entry.args);
  } catch (e) {
    entry.value[1] = e;
  }
  entry.recomputing = false;
}
function mightBeDirty(entry) {
  return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);
}
function setClean(entry) {
  entry.dirty = false;
  if (mightBeDirty(entry)) {
    return;
  }
  reportClean(entry);
}
function reportDirty(child) {
  child.parents.forEach(function(parent) {
    return reportDirtyChild(parent, child);
  });
}
function reportClean(child) {
  child.parents.forEach(function(parent) {
    return reportCleanChild(parent, child);
  });
}
function reportDirtyChild(parent, child) {
  assert(parent.childValues.has(child));
  assert(mightBeDirty(child));
  if (!parent.dirtyChildren) {
    parent.dirtyChildren = emptySetPool.pop() || /* @__PURE__ */ new Set();
  } else if (parent.dirtyChildren.has(child)) {
    return;
  }
  parent.dirtyChildren.add(child);
  reportDirty(parent);
}
function reportCleanChild(parent, child) {
  assert(parent.childValues.has(child));
  assert(!mightBeDirty(child));
  var childValue = parent.childValues.get(child);
  if (childValue.length === 0) {
    parent.childValues.set(child, valueCopy(child.value));
  } else if (!valueIs(childValue, child.value)) {
    parent.setDirty();
  }
  removeDirtyChild(parent, child);
  if (mightBeDirty(parent)) {
    return;
  }
  reportClean(parent);
}
function removeDirtyChild(parent, child) {
  var dc = parent.dirtyChildren;
  if (dc) {
    dc.delete(child);
    if (dc.size === 0) {
      if (emptySetPool.length < POOL_TARGET_SIZE) {
        emptySetPool.push(dc);
      }
      parent.dirtyChildren = null;
    }
  }
}
function maybeReportOrphan(entry) {
  return entry.parents.size === 0 && typeof entry.reportOrphan === "function" && entry.reportOrphan() === true;
}
function forgetChildren(parent) {
  var children = reusableEmptyArray;
  if (parent.childValues.size > 0) {
    children = [];
    parent.childValues.forEach(function(_value, child) {
      forgetChild(parent, child);
      children.push(child);
    });
  }
  assert(parent.dirtyChildren === null);
  return children;
}
function forgetChild(parent, child) {
  child.parents.delete(parent);
  parent.childValues.delete(child);
  removeDirtyChild(parent, child);
}
function maybeSubscribe(entry) {
  if (typeof entry.subscribe === "function") {
    try {
      maybeUnsubscribe(entry);
      entry.unsubscribe = entry.subscribe.apply(null, entry.args);
    } catch (e) {
      entry.setDirty();
      return false;
    }
  }
  return true;
}
function maybeUnsubscribe(entry) {
  var unsubscribe = entry.unsubscribe;
  if (typeof unsubscribe === "function") {
    entry.unsubscribe = void 0;
    unsubscribe();
  }
}
var KeyTrie = function() {
  function KeyTrie2(weakness) {
    this.weakness = weakness;
  }
  KeyTrie2.prototype.lookup = function() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      array[_i] = arguments[_i];
    }
    return this.lookupArray(array);
  };
  KeyTrie2.prototype.lookupArray = function(array) {
    var node = this;
    array.forEach(function(key) {
      return node = node.getChildTrie(key);
    });
    return node.data || (node.data = /* @__PURE__ */ Object.create(null));
  };
  KeyTrie2.prototype.getChildTrie = function(key) {
    var map = this.weakness && isObjRef(key) ? this.weak || (this.weak = /* @__PURE__ */ new WeakMap()) : this.strong || (this.strong = /* @__PURE__ */ new Map());
    var child = map.get(key);
    if (!child)
      map.set(key, child = new KeyTrie2(this.weakness));
    return child;
  };
  return KeyTrie2;
}();
function isObjRef(value) {
  switch (typeof value) {
    case "object":
      if (value === null)
        break;
    case "function":
      return true;
  }
  return false;
}
var keyTrie = new KeyTrie(typeof WeakMap === "function");
function defaultMakeCacheKey() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return keyTrie.lookupArray(args);
}
var caches = /* @__PURE__ */ new Set();
function wrap(originalFunction, options) {
  if (options === void 0) {
    options = /* @__PURE__ */ Object.create(null);
  }
  var cache = new Cache2(options.max || Math.pow(2, 16), function(entry) {
    return entry.dispose();
  });
  var disposable = !!options.disposable;
  var makeCacheKey = options.makeCacheKey || defaultMakeCacheKey;
  function optimistic() {
    if (disposable && !parentEntrySlot.hasValue()) {
      return void 0;
    }
    var key = makeCacheKey.apply(null, arguments);
    if (key === void 0) {
      return originalFunction.apply(null, arguments);
    }
    var args = Array.prototype.slice.call(arguments);
    var entry = cache.get(key);
    if (entry) {
      entry.args = args;
    } else {
      entry = new Entry(originalFunction, args);
      cache.set(key, entry);
      entry.subscribe = options.subscribe;
      if (disposable) {
        entry.reportOrphan = function() {
          return cache.delete(key);
        };
      }
    }
    var value = entry.recompute();
    cache.set(key, entry);
    caches.add(cache);
    if (!parentEntrySlot.hasValue()) {
      caches.forEach(function(cache2) {
        return cache2.clean();
      });
      caches.clear();
    }
    return disposable ? void 0 : value;
  }
  optimistic.dirty = function() {
    var key = makeCacheKey.apply(null, arguments);
    var child = key !== void 0 && cache.get(key);
    if (child) {
      child.setDirty();
    }
  };
  return optimistic;
}

// node_modules/apollo-cache-inmemory/lib/bundle.esm.js
var haveWarned = false;
function shouldWarn() {
  var answer = !haveWarned;
  if (!isTest()) {
    haveWarned = true;
  }
  return answer;
}
var HeuristicFragmentMatcher = function() {
  function HeuristicFragmentMatcher2() {
  }
  HeuristicFragmentMatcher2.prototype.ensureReady = function() {
    return Promise.resolve();
  };
  HeuristicFragmentMatcher2.prototype.canBypassInit = function() {
    return true;
  };
  HeuristicFragmentMatcher2.prototype.match = function(idValue, typeCondition, context) {
    var obj = context.store.get(idValue.id);
    var isRootQuery = idValue.id === "ROOT_QUERY";
    if (!obj) {
      return isRootQuery;
    }
    var _a = obj.__typename, __typename = _a === void 0 ? isRootQuery && "Query" : _a;
    if (!__typename) {
      if (shouldWarn()) {
        invariant.warn("You're using fragments in your queries, but either don't have the addTypename:\n  true option set in Apollo Client, or you are trying to write a fragment to the store without the __typename.\n   Please turn on the addTypename option and include __typename when writing fragments so that Apollo Client\n   can accurately match fragments.");
        invariant.warn("Could not find __typename on Fragment ", typeCondition, obj);
        invariant.warn("DEPRECATION WARNING: using fragments without __typename is unsupported behavior and will be removed in future versions of Apollo client. You should fix this and set addTypename to true now.");
      }
      return "heuristic";
    }
    if (__typename === typeCondition) {
      return true;
    }
    if (shouldWarn()) {
      invariant.error("You are using the simple (heuristic) fragment matcher, but your queries contain union or interface types. Apollo Client will not be able to accurately map fragments. To make this error go away, use the `IntrospectionFragmentMatcher` as described in the docs: https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher");
    }
    return "heuristic";
  };
  return HeuristicFragmentMatcher2;
}();
var IntrospectionFragmentMatcher = function() {
  function IntrospectionFragmentMatcher2(options) {
    if (options && options.introspectionQueryResultData) {
      this.possibleTypesMap = this.parseIntrospectionResult(options.introspectionQueryResultData);
      this.isReady = true;
    } else {
      this.isReady = false;
    }
    this.match = this.match.bind(this);
  }
  IntrospectionFragmentMatcher2.prototype.match = function(idValue, typeCondition, context) {
    false ? invariant(this.isReady, 1) : invariant(this.isReady, "FragmentMatcher.match() was called before FragmentMatcher.init()");
    var obj = context.store.get(idValue.id);
    var isRootQuery = idValue.id === "ROOT_QUERY";
    if (!obj) {
      return isRootQuery;
    }
    var _a = obj.__typename, __typename = _a === void 0 ? isRootQuery && "Query" : _a;
    false ? invariant(__typename, 2) : invariant(__typename, "Cannot match fragment because __typename property is missing: " + JSON.stringify(obj));
    if (__typename === typeCondition) {
      return true;
    }
    var implementingTypes = this.possibleTypesMap[typeCondition];
    if (__typename && implementingTypes && implementingTypes.indexOf(__typename) > -1) {
      return true;
    }
    return false;
  };
  IntrospectionFragmentMatcher2.prototype.parseIntrospectionResult = function(introspectionResultData) {
    var typeMap = {};
    introspectionResultData.__schema.types.forEach(function(type) {
      if (type.kind === "UNION" || type.kind === "INTERFACE") {
        typeMap[type.name] = type.possibleTypes.map(function(implementingType) {
          return implementingType.name;
        });
      }
    });
    return typeMap;
  };
  return IntrospectionFragmentMatcher2;
}();
var hasOwn = Object.prototype.hasOwnProperty;
var DepTrackingCache = function() {
  function DepTrackingCache2(data) {
    var _this = this;
    if (data === void 0) {
      data = /* @__PURE__ */ Object.create(null);
    }
    this.data = data;
    this.depend = wrap(function(dataId) {
      return _this.data[dataId];
    }, {
      disposable: true,
      makeCacheKey: function(dataId) {
        return dataId;
      }
    });
  }
  DepTrackingCache2.prototype.toObject = function() {
    return this.data;
  };
  DepTrackingCache2.prototype.get = function(dataId) {
    this.depend(dataId);
    return this.data[dataId];
  };
  DepTrackingCache2.prototype.set = function(dataId, value) {
    var oldValue = this.data[dataId];
    if (value !== oldValue) {
      this.data[dataId] = value;
      this.depend.dirty(dataId);
    }
  };
  DepTrackingCache2.prototype.delete = function(dataId) {
    if (hasOwn.call(this.data, dataId)) {
      delete this.data[dataId];
      this.depend.dirty(dataId);
    }
  };
  DepTrackingCache2.prototype.clear = function() {
    this.replace(null);
  };
  DepTrackingCache2.prototype.replace = function(newData) {
    var _this = this;
    if (newData) {
      Object.keys(newData).forEach(function(dataId) {
        _this.set(dataId, newData[dataId]);
      });
      Object.keys(this.data).forEach(function(dataId) {
        if (!hasOwn.call(newData, dataId)) {
          _this.delete(dataId);
        }
      });
    } else {
      Object.keys(this.data).forEach(function(dataId) {
        _this.delete(dataId);
      });
    }
  };
  return DepTrackingCache2;
}();
function defaultNormalizedCacheFactory(seed) {
  return new DepTrackingCache(seed);
}
var StoreReader = function() {
  function StoreReader2(_a) {
    var _this = this;
    var _b = _a === void 0 ? {} : _a, _c = _b.cacheKeyRoot, cacheKeyRoot = _c === void 0 ? new KeyTrie(canUseWeakMap) : _c, _d = _b.freezeResults, freezeResults = _d === void 0 ? false : _d;
    var _e = this, executeStoreQuery = _e.executeStoreQuery, executeSelectionSet = _e.executeSelectionSet, executeSubSelectedArray = _e.executeSubSelectedArray;
    this.freezeResults = freezeResults;
    this.executeStoreQuery = wrap(function(options) {
      return executeStoreQuery.call(_this, options);
    }, {
      makeCacheKey: function(_a2) {
        var query = _a2.query, rootValue = _a2.rootValue, contextValue = _a2.contextValue, variableValues = _a2.variableValues, fragmentMatcher = _a2.fragmentMatcher;
        if (contextValue.store instanceof DepTrackingCache) {
          return cacheKeyRoot.lookup(contextValue.store, query, fragmentMatcher, JSON.stringify(variableValues), rootValue.id);
        }
      }
    });
    this.executeSelectionSet = wrap(function(options) {
      return executeSelectionSet.call(_this, options);
    }, {
      makeCacheKey: function(_a2) {
        var selectionSet = _a2.selectionSet, rootValue = _a2.rootValue, execContext = _a2.execContext;
        if (execContext.contextValue.store instanceof DepTrackingCache) {
          return cacheKeyRoot.lookup(execContext.contextValue.store, selectionSet, execContext.fragmentMatcher, JSON.stringify(execContext.variableValues), rootValue.id);
        }
      }
    });
    this.executeSubSelectedArray = wrap(function(options) {
      return executeSubSelectedArray.call(_this, options);
    }, {
      makeCacheKey: function(_a2) {
        var field = _a2.field, array = _a2.array, execContext = _a2.execContext;
        if (execContext.contextValue.store instanceof DepTrackingCache) {
          return cacheKeyRoot.lookup(execContext.contextValue.store, field, array, JSON.stringify(execContext.variableValues));
        }
      }
    });
  }
  StoreReader2.prototype.readQueryFromStore = function(options) {
    return this.diffQueryAgainstStore(__assign(__assign({}, options), { returnPartialData: false })).result;
  };
  StoreReader2.prototype.diffQueryAgainstStore = function(_a) {
    var store = _a.store, query = _a.query, variables = _a.variables, previousResult = _a.previousResult, _b = _a.returnPartialData, returnPartialData = _b === void 0 ? true : _b, _c = _a.rootId, rootId = _c === void 0 ? "ROOT_QUERY" : _c, fragmentMatcherFunction = _a.fragmentMatcherFunction, config = _a.config;
    var queryDefinition = getQueryDefinition(query);
    variables = assign({}, getDefaultValues(queryDefinition), variables);
    var context = {
      store,
      dataIdFromObject: config && config.dataIdFromObject,
      cacheRedirects: config && config.cacheRedirects || {}
    };
    var execResult = this.executeStoreQuery({
      query,
      rootValue: {
        type: "id",
        id: rootId,
        generated: true,
        typename: "Query"
      },
      contextValue: context,
      variableValues: variables,
      fragmentMatcher: fragmentMatcherFunction
    });
    var hasMissingFields = execResult.missing && execResult.missing.length > 0;
    if (hasMissingFields && !returnPartialData) {
      execResult.missing.forEach(function(info) {
        if (info.tolerable)
          return;
        throw false ? new InvariantError(8) : new InvariantError("Can't find field " + info.fieldName + " on object " + JSON.stringify(info.object, null, 2) + ".");
      });
    }
    if (previousResult) {
      if (equal(previousResult, execResult.result)) {
        execResult.result = previousResult;
      }
    }
    return {
      result: execResult.result,
      complete: !hasMissingFields
    };
  };
  StoreReader2.prototype.executeStoreQuery = function(_a) {
    var query = _a.query, rootValue = _a.rootValue, contextValue = _a.contextValue, variableValues = _a.variableValues, _b = _a.fragmentMatcher, fragmentMatcher = _b === void 0 ? defaultFragmentMatcher : _b;
    var mainDefinition = getMainDefinition(query);
    var fragments = getFragmentDefinitions(query);
    var fragmentMap = createFragmentMap(fragments);
    var execContext = {
      query,
      fragmentMap,
      contextValue,
      variableValues,
      fragmentMatcher
    };
    return this.executeSelectionSet({
      selectionSet: mainDefinition.selectionSet,
      rootValue,
      execContext
    });
  };
  StoreReader2.prototype.executeSelectionSet = function(_a) {
    var _this = this;
    var selectionSet = _a.selectionSet, rootValue = _a.rootValue, execContext = _a.execContext;
    var fragmentMap = execContext.fragmentMap, contextValue = execContext.contextValue, variables = execContext.variableValues;
    var finalResult = { result: null };
    var objectsToMerge = [];
    var object = contextValue.store.get(rootValue.id);
    var typename = object && object.__typename || rootValue.id === "ROOT_QUERY" && "Query" || void 0;
    function handleMissing(result) {
      var _a2;
      if (result.missing) {
        finalResult.missing = finalResult.missing || [];
        (_a2 = finalResult.missing).push.apply(_a2, result.missing);
      }
      return result.result;
    }
    selectionSet.selections.forEach(function(selection) {
      var _a2;
      if (!shouldInclude(selection, variables)) {
        return;
      }
      if (isField(selection)) {
        var fieldResult = handleMissing(_this.executeField(object, typename, selection, execContext));
        if (typeof fieldResult !== "undefined") {
          objectsToMerge.push((_a2 = {}, _a2[resultKeyNameFromField(selection)] = fieldResult, _a2));
        }
      } else {
        var fragment = void 0;
        if (isInlineFragment(selection)) {
          fragment = selection;
        } else {
          fragment = fragmentMap[selection.name.value];
          if (!fragment) {
            throw false ? new InvariantError(9) : new InvariantError("No fragment named " + selection.name.value);
          }
        }
        var typeCondition = fragment.typeCondition && fragment.typeCondition.name.value;
        var match = !typeCondition || execContext.fragmentMatcher(rootValue, typeCondition, contextValue);
        if (match) {
          var fragmentExecResult = _this.executeSelectionSet({
            selectionSet: fragment.selectionSet,
            rootValue,
            execContext
          });
          if (match === "heuristic" && fragmentExecResult.missing) {
            fragmentExecResult = __assign(__assign({}, fragmentExecResult), { missing: fragmentExecResult.missing.map(function(info) {
              return __assign(__assign({}, info), { tolerable: true });
            }) });
          }
          objectsToMerge.push(handleMissing(fragmentExecResult));
        }
      }
    });
    finalResult.result = mergeDeepArray(objectsToMerge);
    if (this.freezeResults && true) {
      Object.freeze(finalResult.result);
    }
    return finalResult;
  };
  StoreReader2.prototype.executeField = function(object, typename, field, execContext) {
    var variables = execContext.variableValues, contextValue = execContext.contextValue;
    var fieldName = field.name.value;
    var args = argumentsObjectFromField(field, variables);
    var info = {
      resultKey: resultKeyNameFromField(field),
      directives: getDirectiveInfoFromField(field, variables)
    };
    var readStoreResult = readStoreResolver(object, typename, fieldName, args, contextValue, info);
    if (Array.isArray(readStoreResult.result)) {
      return this.combineExecResults(readStoreResult, this.executeSubSelectedArray({
        field,
        array: readStoreResult.result,
        execContext
      }));
    }
    if (!field.selectionSet) {
      assertSelectionSetForIdValue(field, readStoreResult.result);
      if (this.freezeResults && true) {
        maybeDeepFreeze(readStoreResult);
      }
      return readStoreResult;
    }
    if (readStoreResult.result == null) {
      return readStoreResult;
    }
    return this.combineExecResults(readStoreResult, this.executeSelectionSet({
      selectionSet: field.selectionSet,
      rootValue: readStoreResult.result,
      execContext
    }));
  };
  StoreReader2.prototype.combineExecResults = function() {
    var execResults = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      execResults[_i] = arguments[_i];
    }
    var missing;
    execResults.forEach(function(execResult) {
      if (execResult.missing) {
        missing = missing || [];
        missing.push.apply(missing, execResult.missing);
      }
    });
    return {
      result: execResults.pop().result,
      missing
    };
  };
  StoreReader2.prototype.executeSubSelectedArray = function(_a) {
    var _this = this;
    var field = _a.field, array = _a.array, execContext = _a.execContext;
    var missing;
    function handleMissing(childResult) {
      if (childResult.missing) {
        missing = missing || [];
        missing.push.apply(missing, childResult.missing);
      }
      return childResult.result;
    }
    array = array.map(function(item) {
      if (item === null) {
        return null;
      }
      if (Array.isArray(item)) {
        return handleMissing(_this.executeSubSelectedArray({
          field,
          array: item,
          execContext
        }));
      }
      if (field.selectionSet) {
        return handleMissing(_this.executeSelectionSet({
          selectionSet: field.selectionSet,
          rootValue: item,
          execContext
        }));
      }
      assertSelectionSetForIdValue(field, item);
      return item;
    });
    if (this.freezeResults && true) {
      Object.freeze(array);
    }
    return { result: array, missing };
  };
  return StoreReader2;
}();
function assertSelectionSetForIdValue(field, value) {
  if (!field.selectionSet && isIdValue(value)) {
    throw false ? new InvariantError(10) : new InvariantError("Missing selection set for object of type " + value.typename + " returned for query field " + field.name.value);
  }
}
function defaultFragmentMatcher() {
  return true;
}
function assertIdValue(idValue) {
  false ? invariant(isIdValue(idValue), 11) : invariant(isIdValue(idValue), "Encountered a sub-selection on the query, but the store doesn't have an object reference. This should never happen during normal use unless you have custom code that is directly manipulating the store; please file an issue.");
}
function readStoreResolver(object, typename, fieldName, args, context, _a) {
  var resultKey = _a.resultKey, directives = _a.directives;
  var storeKeyName = fieldName;
  if (args || directives) {
    storeKeyName = getStoreKeyName(storeKeyName, args, directives);
  }
  var fieldValue = void 0;
  if (object) {
    fieldValue = object[storeKeyName];
    if (typeof fieldValue === "undefined" && context.cacheRedirects && typeof typename === "string") {
      var type = context.cacheRedirects[typename];
      if (type) {
        var resolver = type[fieldName];
        if (resolver) {
          fieldValue = resolver(object, args, {
            getCacheKey: function(storeObj) {
              var id = context.dataIdFromObject(storeObj);
              return id && toIdValue({
                id,
                typename: storeObj.__typename
              });
            }
          });
        }
      }
    }
  }
  if (typeof fieldValue === "undefined") {
    return {
      result: fieldValue,
      missing: [{
        object,
        fieldName: storeKeyName,
        tolerable: false
      }]
    };
  }
  if (isJsonValue(fieldValue)) {
    fieldValue = fieldValue.json;
  }
  return {
    result: fieldValue
  };
}
var ObjectCache = function() {
  function ObjectCache2(data) {
    if (data === void 0) {
      data = /* @__PURE__ */ Object.create(null);
    }
    this.data = data;
  }
  ObjectCache2.prototype.toObject = function() {
    return this.data;
  };
  ObjectCache2.prototype.get = function(dataId) {
    return this.data[dataId];
  };
  ObjectCache2.prototype.set = function(dataId, value) {
    this.data[dataId] = value;
  };
  ObjectCache2.prototype.delete = function(dataId) {
    this.data[dataId] = void 0;
  };
  ObjectCache2.prototype.clear = function() {
    this.data = /* @__PURE__ */ Object.create(null);
  };
  ObjectCache2.prototype.replace = function(newData) {
    this.data = newData || /* @__PURE__ */ Object.create(null);
  };
  return ObjectCache2;
}();
function defaultNormalizedCacheFactory$1(seed) {
  return new ObjectCache(seed);
}
var WriteError = function(_super) {
  __extends(WriteError2, _super);
  function WriteError2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "WriteError";
    return _this;
  }
  return WriteError2;
}(Error);
function enhanceErrorWithDocument(error, document) {
  var enhancedError = new WriteError("Error writing result to store for query:\n " + JSON.stringify(document));
  enhancedError.message += "\n" + error.message;
  enhancedError.stack = error.stack;
  return enhancedError;
}
var StoreWriter = function() {
  function StoreWriter2() {
  }
  StoreWriter2.prototype.writeQueryToStore = function(_a) {
    var query = _a.query, result = _a.result, _b = _a.store, store = _b === void 0 ? defaultNormalizedCacheFactory() : _b, variables = _a.variables, dataIdFromObject = _a.dataIdFromObject, fragmentMatcherFunction = _a.fragmentMatcherFunction;
    return this.writeResultToStore({
      dataId: "ROOT_QUERY",
      result,
      document: query,
      store,
      variables,
      dataIdFromObject,
      fragmentMatcherFunction
    });
  };
  StoreWriter2.prototype.writeResultToStore = function(_a) {
    var dataId = _a.dataId, result = _a.result, document = _a.document, _b = _a.store, store = _b === void 0 ? defaultNormalizedCacheFactory() : _b, variables = _a.variables, dataIdFromObject = _a.dataIdFromObject, fragmentMatcherFunction = _a.fragmentMatcherFunction;
    var operationDefinition = getOperationDefinition(document);
    try {
      return this.writeSelectionSetToStore({
        result,
        dataId,
        selectionSet: operationDefinition.selectionSet,
        context: {
          store,
          processedData: {},
          variables: assign({}, getDefaultValues(operationDefinition), variables),
          dataIdFromObject,
          fragmentMap: createFragmentMap(getFragmentDefinitions(document)),
          fragmentMatcherFunction
        }
      });
    } catch (e) {
      throw enhanceErrorWithDocument(e, document);
    }
  };
  StoreWriter2.prototype.writeSelectionSetToStore = function(_a) {
    var _this = this;
    var result = _a.result, dataId = _a.dataId, selectionSet = _a.selectionSet, context = _a.context;
    var variables = context.variables, store = context.store, fragmentMap = context.fragmentMap;
    selectionSet.selections.forEach(function(selection) {
      var _a2;
      if (!shouldInclude(selection, variables)) {
        return;
      }
      if (isField(selection)) {
        var resultFieldKey = resultKeyNameFromField(selection);
        var value = result[resultFieldKey];
        if (typeof value !== "undefined") {
          _this.writeFieldToStore({
            dataId,
            value,
            field: selection,
            context
          });
        } else {
          var isDefered = false;
          var isClient = false;
          if (selection.directives && selection.directives.length) {
            isDefered = selection.directives.some(function(directive) {
              return directive.name && directive.name.value === "defer";
            });
            isClient = selection.directives.some(function(directive) {
              return directive.name && directive.name.value === "client";
            });
          }
          if (!isDefered && !isClient && context.fragmentMatcherFunction) {
            invariant.warn("Missing field " + resultFieldKey + " in " + JSON.stringify(result, null, 2).substring(0, 100));
          }
        }
      } else {
        var fragment = void 0;
        if (isInlineFragment(selection)) {
          fragment = selection;
        } else {
          fragment = (fragmentMap || {})[selection.name.value];
          false ? invariant(fragment, 3) : invariant(fragment, "No fragment named " + selection.name.value + ".");
        }
        var matches = true;
        if (context.fragmentMatcherFunction && fragment.typeCondition) {
          var id = dataId || "self";
          var idValue = toIdValue({ id, typename: void 0 });
          var fakeContext = {
            store: new ObjectCache((_a2 = {}, _a2[id] = result, _a2)),
            cacheRedirects: {}
          };
          var match = context.fragmentMatcherFunction(idValue, fragment.typeCondition.name.value, fakeContext);
          if (!isProduction() && match === "heuristic") {
            invariant.error("WARNING: heuristic fragment matching going on!");
          }
          matches = !!match;
        }
        if (matches) {
          _this.writeSelectionSetToStore({
            result,
            selectionSet: fragment.selectionSet,
            dataId,
            context
          });
        }
      }
    });
    return store;
  };
  StoreWriter2.prototype.writeFieldToStore = function(_a) {
    var _b;
    var field = _a.field, value = _a.value, dataId = _a.dataId, context = _a.context;
    var variables = context.variables, dataIdFromObject = context.dataIdFromObject, store = context.store;
    var storeValue;
    var storeObject;
    var storeFieldName = storeKeyNameFromField(field, variables);
    if (!field.selectionSet || value === null) {
      storeValue = value != null && typeof value === "object" ? { type: "json", json: value } : value;
    } else if (Array.isArray(value)) {
      var generatedId = dataId + "." + storeFieldName;
      storeValue = this.processArrayValue(value, generatedId, field.selectionSet, context);
    } else {
      var valueDataId = dataId + "." + storeFieldName;
      var generated = true;
      if (!isGeneratedId(valueDataId)) {
        valueDataId = "$" + valueDataId;
      }
      if (dataIdFromObject) {
        var semanticId = dataIdFromObject(value);
        false ? invariant(!semanticId || !isGeneratedId(semanticId), 4) : invariant(!semanticId || !isGeneratedId(semanticId), 'IDs returned by dataIdFromObject cannot begin with the "$" character.');
        if (semanticId || typeof semanticId === "number" && semanticId === 0) {
          valueDataId = semanticId;
          generated = false;
        }
      }
      if (!isDataProcessed(valueDataId, field, context.processedData)) {
        this.writeSelectionSetToStore({
          dataId: valueDataId,
          result: value,
          selectionSet: field.selectionSet,
          context
        });
      }
      var typename = value.__typename;
      storeValue = toIdValue({ id: valueDataId, typename }, generated);
      storeObject = store.get(dataId);
      var escapedId = storeObject && storeObject[storeFieldName];
      if (escapedId !== storeValue && isIdValue(escapedId)) {
        var hadTypename = escapedId.typename !== void 0;
        var hasTypename = typename !== void 0;
        var typenameChanged = hadTypename && hasTypename && escapedId.typename !== typename;
        false ? invariant(!generated || escapedId.generated || typenameChanged, 5) : invariant(!generated || escapedId.generated || typenameChanged, "Store error: the application attempted to write an object with no provided id but the store already contains an id of " + escapedId.id + " for this object. The selectionSet that was trying to be written is:\n" + JSON.stringify(field));
        false ? invariant(!hadTypename || hasTypename, 6) : invariant(!hadTypename || hasTypename, "Store error: the application attempted to write an object with no provided typename but the store already contains an object with typename of " + escapedId.typename + " for the object of id " + escapedId.id + ". The selectionSet that was trying to be written is:\n" + JSON.stringify(field));
        if (escapedId.generated) {
          if (typenameChanged) {
            if (!generated) {
              store.delete(escapedId.id);
            }
          } else {
            mergeWithGenerated(escapedId.id, storeValue.id, store);
          }
        }
      }
    }
    storeObject = store.get(dataId);
    if (!storeObject || !equal(storeValue, storeObject[storeFieldName])) {
      store.set(dataId, __assign(__assign({}, storeObject), (_b = {}, _b[storeFieldName] = storeValue, _b)));
    }
  };
  StoreWriter2.prototype.processArrayValue = function(value, generatedId, selectionSet, context) {
    var _this = this;
    return value.map(function(item, index) {
      if (item === null) {
        return null;
      }
      var itemDataId = generatedId + "." + index;
      if (Array.isArray(item)) {
        return _this.processArrayValue(item, itemDataId, selectionSet, context);
      }
      var generated = true;
      if (context.dataIdFromObject) {
        var semanticId = context.dataIdFromObject(item);
        if (semanticId) {
          itemDataId = semanticId;
          generated = false;
        }
      }
      if (!isDataProcessed(itemDataId, selectionSet, context.processedData)) {
        _this.writeSelectionSetToStore({
          dataId: itemDataId,
          result: item,
          selectionSet,
          context
        });
      }
      return toIdValue({ id: itemDataId, typename: item.__typename }, generated);
    });
  };
  return StoreWriter2;
}();
function isGeneratedId(id) {
  return id[0] === "$";
}
function mergeWithGenerated(generatedKey, realKey, cache) {
  if (generatedKey === realKey) {
    return false;
  }
  var generated = cache.get(generatedKey);
  var real = cache.get(realKey);
  var madeChanges = false;
  Object.keys(generated).forEach(function(key) {
    var value = generated[key];
    var realValue = real[key];
    if (isIdValue(value) && isGeneratedId(value.id) && isIdValue(realValue) && !equal(value, realValue) && mergeWithGenerated(value.id, realValue.id, cache)) {
      madeChanges = true;
    }
  });
  cache.delete(generatedKey);
  var newRealValue = __assign(__assign({}, generated), real);
  if (equal(newRealValue, real)) {
    return madeChanges;
  }
  cache.set(realKey, newRealValue);
  return true;
}
function isDataProcessed(dataId, field, processedData) {
  if (!processedData) {
    return false;
  }
  if (processedData[dataId]) {
    if (processedData[dataId].indexOf(field) >= 0) {
      return true;
    } else {
      processedData[dataId].push(field);
    }
  } else {
    processedData[dataId] = [field];
  }
  return false;
}
var defaultConfig = {
  fragmentMatcher: new HeuristicFragmentMatcher(),
  dataIdFromObject: defaultDataIdFromObject,
  addTypename: true,
  resultCaching: true,
  freezeResults: false
};
function defaultDataIdFromObject(result) {
  if (result.__typename) {
    if (result.id !== void 0) {
      return result.__typename + ":" + result.id;
    }
    if (result._id !== void 0) {
      return result.__typename + ":" + result._id;
    }
  }
  return null;
}
var hasOwn$1 = Object.prototype.hasOwnProperty;
var OptimisticCacheLayer = function(_super) {
  __extends(OptimisticCacheLayer2, _super);
  function OptimisticCacheLayer2(optimisticId, parent, transaction) {
    var _this = _super.call(this, /* @__PURE__ */ Object.create(null)) || this;
    _this.optimisticId = optimisticId;
    _this.parent = parent;
    _this.transaction = transaction;
    return _this;
  }
  OptimisticCacheLayer2.prototype.toObject = function() {
    return __assign(__assign({}, this.parent.toObject()), this.data);
  };
  OptimisticCacheLayer2.prototype.get = function(dataId) {
    return hasOwn$1.call(this.data, dataId) ? this.data[dataId] : this.parent.get(dataId);
  };
  return OptimisticCacheLayer2;
}(ObjectCache);
var InMemoryCache = function(_super) {
  __extends(InMemoryCache2, _super);
  function InMemoryCache2(config) {
    if (config === void 0) {
      config = {};
    }
    var _this = _super.call(this) || this;
    _this.watches = /* @__PURE__ */ new Set();
    _this.typenameDocumentCache = /* @__PURE__ */ new Map();
    _this.cacheKeyRoot = new KeyTrie(canUseWeakMap);
    _this.silenceBroadcast = false;
    _this.config = __assign(__assign({}, defaultConfig), config);
    if (_this.config.customResolvers) {
      invariant.warn("customResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating customResolvers in the next major version.");
      _this.config.cacheRedirects = _this.config.customResolvers;
    }
    if (_this.config.cacheResolvers) {
      invariant.warn("cacheResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating cacheResolvers in the next major version.");
      _this.config.cacheRedirects = _this.config.cacheResolvers;
    }
    _this.addTypename = !!_this.config.addTypename;
    _this.data = _this.config.resultCaching ? new DepTrackingCache() : new ObjectCache();
    _this.optimisticData = _this.data;
    _this.storeWriter = new StoreWriter();
    _this.storeReader = new StoreReader({
      cacheKeyRoot: _this.cacheKeyRoot,
      freezeResults: config.freezeResults
    });
    var cache = _this;
    var maybeBroadcastWatch = cache.maybeBroadcastWatch;
    _this.maybeBroadcastWatch = wrap(function(c) {
      return maybeBroadcastWatch.call(_this, c);
    }, {
      makeCacheKey: function(c) {
        if (c.optimistic) {
          return;
        }
        if (c.previousResult) {
          return;
        }
        if (cache.data instanceof DepTrackingCache) {
          return cache.cacheKeyRoot.lookup(c.query, JSON.stringify(c.variables));
        }
      }
    });
    return _this;
  }
  InMemoryCache2.prototype.restore = function(data) {
    if (data)
      this.data.replace(data);
    return this;
  };
  InMemoryCache2.prototype.extract = function(optimistic) {
    if (optimistic === void 0) {
      optimistic = false;
    }
    return (optimistic ? this.optimisticData : this.data).toObject();
  };
  InMemoryCache2.prototype.read = function(options) {
    if (typeof options.rootId === "string" && typeof this.data.get(options.rootId) === "undefined") {
      return null;
    }
    var fragmentMatcher = this.config.fragmentMatcher;
    var fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;
    return this.storeReader.readQueryFromStore({
      store: options.optimistic ? this.optimisticData : this.data,
      query: this.transformDocument(options.query),
      variables: options.variables,
      rootId: options.rootId,
      fragmentMatcherFunction,
      previousResult: options.previousResult,
      config: this.config
    }) || null;
  };
  InMemoryCache2.prototype.write = function(write) {
    var fragmentMatcher = this.config.fragmentMatcher;
    var fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;
    this.storeWriter.writeResultToStore({
      dataId: write.dataId,
      result: write.result,
      variables: write.variables,
      document: this.transformDocument(write.query),
      store: this.data,
      dataIdFromObject: this.config.dataIdFromObject,
      fragmentMatcherFunction
    });
    this.broadcastWatches();
  };
  InMemoryCache2.prototype.diff = function(query) {
    var fragmentMatcher = this.config.fragmentMatcher;
    var fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;
    return this.storeReader.diffQueryAgainstStore({
      store: query.optimistic ? this.optimisticData : this.data,
      query: this.transformDocument(query.query),
      variables: query.variables,
      returnPartialData: query.returnPartialData,
      previousResult: query.previousResult,
      fragmentMatcherFunction,
      config: this.config
    });
  };
  InMemoryCache2.prototype.watch = function(watch) {
    var _this = this;
    this.watches.add(watch);
    return function() {
      _this.watches.delete(watch);
    };
  };
  InMemoryCache2.prototype.evict = function(query) {
    throw false ? new InvariantError(7) : new InvariantError("eviction is not implemented on InMemory Cache");
  };
  InMemoryCache2.prototype.reset = function() {
    this.data.clear();
    this.broadcastWatches();
    return Promise.resolve();
  };
  InMemoryCache2.prototype.removeOptimistic = function(idToRemove) {
    var toReapply = [];
    var removedCount = 0;
    var layer = this.optimisticData;
    while (layer instanceof OptimisticCacheLayer) {
      if (layer.optimisticId === idToRemove) {
        ++removedCount;
      } else {
        toReapply.push(layer);
      }
      layer = layer.parent;
    }
    if (removedCount > 0) {
      this.optimisticData = layer;
      while (toReapply.length > 0) {
        var layer_1 = toReapply.pop();
        this.performTransaction(layer_1.transaction, layer_1.optimisticId);
      }
      this.broadcastWatches();
    }
  };
  InMemoryCache2.prototype.performTransaction = function(transaction, optimisticId) {
    var _a = this, data = _a.data, silenceBroadcast = _a.silenceBroadcast;
    this.silenceBroadcast = true;
    if (typeof optimisticId === "string") {
      this.data = this.optimisticData = new OptimisticCacheLayer(optimisticId, this.optimisticData, transaction);
    }
    try {
      transaction(this);
    } finally {
      this.silenceBroadcast = silenceBroadcast;
      this.data = data;
    }
    this.broadcastWatches();
  };
  InMemoryCache2.prototype.recordOptimisticTransaction = function(transaction, id) {
    return this.performTransaction(transaction, id);
  };
  InMemoryCache2.prototype.transformDocument = function(document) {
    if (this.addTypename) {
      var result = this.typenameDocumentCache.get(document);
      if (!result) {
        result = addTypenameToDocument(document);
        this.typenameDocumentCache.set(document, result);
        this.typenameDocumentCache.set(result, result);
      }
      return result;
    }
    return document;
  };
  InMemoryCache2.prototype.broadcastWatches = function() {
    var _this = this;
    if (!this.silenceBroadcast) {
      this.watches.forEach(function(c) {
        return _this.maybeBroadcastWatch(c);
      });
    }
  };
  InMemoryCache2.prototype.maybeBroadcastWatch = function(c) {
    c.callback(this.diff({
      query: c.query,
      variables: c.variables,
      previousResult: c.previousResult && c.previousResult(),
      optimistic: c.optimistic
    }));
  };
  return InMemoryCache2;
}(ApolloCache);
export {
  HeuristicFragmentMatcher,
  InMemoryCache,
  IntrospectionFragmentMatcher,
  ObjectCache,
  StoreReader,
  StoreWriter,
  WriteError,
  assertIdValue,
  defaultDataIdFromObject,
  defaultNormalizedCacheFactory$1 as defaultNormalizedCacheFactory,
  enhanceErrorWithDocument
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
//# sourceMappingURL=apollo-cache-inmemory.js.map
