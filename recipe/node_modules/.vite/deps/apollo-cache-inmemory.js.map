{
  "version": 3,
  "sources": ["../../apollo-cache-inmemory/node_modules/tslib/tslib.es6.js", "../../apollo-cache/src/utils.ts", "../../apollo-cache/src/cache.ts", "../../apollo-cache/src/types/Cache.ts", "../../@wry/context/src/slot.ts", "../../@wry/context/src/context.ts", "../../optimism/src/cache.ts", "../../optimism/src/context.ts", "../../optimism/src/entry.ts", "../../optimism/src/key-trie.ts", "../../optimism/src/index.ts", "../../apollo-cache-inmemory/src/fragmentMatcher.ts", "../../apollo-cache-inmemory/src/depTrackingCache.ts", "../../apollo-cache-inmemory/src/readFromStore.ts", "../../apollo-cache-inmemory/src/objectCache.ts", "../../apollo-cache-inmemory/src/writeToStore.ts", "../../apollo-cache-inmemory/src/inMemoryCache.ts"],
  "sourcesContent": ["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n", "import {\n  DocumentNode,\n  OperationDefinitionNode,\n  SelectionSetNode,\n  FieldNode,\n  FragmentDefinitionNode,\n} from 'graphql';\n\nexport function queryFromPojo(obj: any): DocumentNode {\n  const op: OperationDefinitionNode = {\n    kind: 'OperationDefinition',\n    operation: 'query',\n    name: {\n      kind: 'Name',\n      value: 'GeneratedClientQuery',\n    },\n    selectionSet: selectionSetFromObj(obj),\n  };\n\n  const out: DocumentNode = {\n    kind: 'Document',\n    definitions: [op],\n  };\n\n  return out;\n}\n\nexport function fragmentFromPojo(obj: any, typename?: string): DocumentNode {\n  const frag: FragmentDefinitionNode = {\n    kind: 'FragmentDefinition',\n    typeCondition: {\n      kind: 'NamedType',\n      name: {\n        kind: 'Name',\n        value: typename || '__FakeType',\n      },\n    },\n    name: {\n      kind: 'Name',\n      value: 'GeneratedClientQuery',\n    },\n    selectionSet: selectionSetFromObj(obj),\n  };\n\n  const out: DocumentNode = {\n    kind: 'Document',\n    definitions: [frag],\n  };\n\n  return out;\n}\n\nfunction selectionSetFromObj(obj: any): SelectionSetNode {\n  if (\n    typeof obj === 'number' ||\n    typeof obj === 'boolean' ||\n    typeof obj === 'string' ||\n    typeof obj === 'undefined' ||\n    obj === null\n  ) {\n    // No selection set here\n    return null;\n  }\n\n  if (Array.isArray(obj)) {\n    // GraphQL queries don't include arrays\n    return selectionSetFromObj(obj[0]);\n  }\n\n  // Now we know it's an object\n  const selections: FieldNode[] = [];\n\n  Object.keys(obj).forEach(key => {\n    const nestedSelSet: SelectionSetNode = selectionSetFromObj(obj[key]);\n\n    const field: FieldNode = {\n      kind: 'Field',\n      name: {\n        kind: 'Name',\n        value: key,\n      },\n      selectionSet: nestedSelSet || undefined,\n    };\n\n    selections.push(field);\n  });\n\n  const selectionSet: SelectionSetNode = {\n    kind: 'SelectionSet',\n    selections,\n  };\n\n  return selectionSet;\n}\n\nexport const justTypenameQuery: DocumentNode = {\n  kind: 'Document',\n  definitions: [\n    {\n      kind: 'OperationDefinition',\n      operation: 'query',\n      name: null,\n      variableDefinitions: null,\n      directives: [],\n      selectionSet: {\n        kind: 'SelectionSet',\n        selections: [\n          {\n            kind: 'Field',\n            alias: null,\n            name: {\n              kind: 'Name',\n              value: '__typename',\n            },\n            arguments: [],\n            directives: [],\n            selectionSet: null,\n          },\n        ],\n      },\n    },\n  ],\n};\n", "import { DocumentNode } from 'graphql';\nimport { getFragmentQueryDocument } from 'apollo-utilities';\n\nimport { DataProxy, Cache } from './types';\nimport { justTypenameQuery, queryFromPojo, fragmentFromPojo } from './utils';\n\nexport type Transaction<T> = (c: ApolloCache<T>) => void;\n\nexport abstract class ApolloCache<TSerialized> implements DataProxy {\n  // required to implement\n  // core API\n  public abstract read<T, TVariables = any>(\n    query: Cache.ReadOptions<TVariables>,\n  ): T | null;\n  public abstract write<TResult = any, TVariables = any>(\n    write: Cache.WriteOptions<TResult, TVariables>,\n  ): void;\n  public abstract diff<T>(query: Cache.DiffOptions): Cache.DiffResult<T>;\n  public abstract watch(watch: Cache.WatchOptions): () => void;\n  public abstract evict<TVariables = any>(\n    query: Cache.EvictOptions<TVariables>,\n  ): Cache.EvictionResult;\n  public abstract reset(): Promise<void>;\n\n  // intializer / offline / ssr API\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  public abstract restore(\n    serializedState: TSerialized,\n  ): ApolloCache<TSerialized>;\n\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   */\n  public abstract extract(optimistic?: boolean): TSerialized;\n\n  // optimistic API\n  public abstract removeOptimistic(id: string): void;\n\n  // transactional API\n  public abstract performTransaction(\n    transaction: Transaction<TSerialized>,\n  ): void;\n  public abstract recordOptimisticTransaction(\n    transaction: Transaction<TSerialized>,\n    id: string,\n  ): void;\n\n  // optional API\n  public transformDocument(document: DocumentNode): DocumentNode {\n    return document;\n  }\n  // experimental\n  public transformForLink(document: DocumentNode): DocumentNode {\n    return document;\n  }\n\n  // DataProxy API\n  /**\n   *\n   * @param options\n   * @param optimistic\n   */\n  public readQuery<QueryType, TVariables = any>(\n    options: DataProxy.Query<TVariables>,\n    optimistic: boolean = false,\n  ): QueryType | null {\n    return this.read({\n      query: options.query,\n      variables: options.variables,\n      optimistic,\n    });\n  }\n\n  public readFragment<FragmentType, TVariables = any>(\n    options: DataProxy.Fragment<TVariables>,\n    optimistic: boolean = false,\n  ): FragmentType | null {\n    return this.read({\n      query: getFragmentQueryDocument(options.fragment, options.fragmentName),\n      variables: options.variables,\n      rootId: options.id,\n      optimistic,\n    });\n  }\n\n  public writeQuery<TData = any, TVariables = any>(\n    options: Cache.WriteQueryOptions<TData, TVariables>,\n  ): void {\n    this.write({\n      dataId: 'ROOT_QUERY',\n      result: options.data,\n      query: options.query,\n      variables: options.variables,\n    });\n  }\n\n  public writeFragment<TData = any, TVariables = any>(\n    options: Cache.WriteFragmentOptions<TData, TVariables>,\n  ): void {\n    this.write({\n      dataId: options.id,\n      result: options.data,\n      variables: options.variables,\n      query: getFragmentQueryDocument(options.fragment, options.fragmentName),\n    });\n  }\n\n  public writeData<TData = any>({\n    id,\n    data,\n  }: Cache.WriteDataOptions<TData>): void {\n    if (typeof id !== 'undefined') {\n      let typenameResult = null;\n      // Since we can't use fragments without having a typename in the store,\n      // we need to make sure we have one.\n      // To avoid overwriting an existing typename, we need to read it out first\n      // and generate a fake one if none exists.\n      try {\n        typenameResult = this.read<any>({\n          rootId: id,\n          optimistic: false,\n          query: justTypenameQuery,\n        });\n      } catch (e) {\n        // Do nothing, since an error just means no typename exists\n      }\n\n      // tslint:disable-next-line\n      const __typename =\n        (typenameResult && typenameResult.__typename) || '__ClientData';\n\n      // Add a type here to satisfy the inmemory cache\n      const dataToWrite = Object.assign({ __typename }, data);\n\n      this.writeFragment({\n        id,\n        fragment: fragmentFromPojo(dataToWrite, __typename),\n        data: dataToWrite,\n      });\n    } else {\n      this.writeQuery({ query: queryFromPojo(data), data });\n    }\n  }\n}\n", "import { DataProxy } from './DataProxy';\n\nexport namespace Cache {\n  export type WatchCallback = (newData: any) => void;\n  export interface EvictionResult {\n    success: Boolean;\n  }\n\n  export interface ReadOptions<TVariables = any>\n    extends DataProxy.Query<TVariables> {\n    rootId?: string;\n    previousResult?: any;\n    optimistic: boolean;\n  }\n\n  export interface WriteOptions<TResult = any, TVariables = any>\n    extends DataProxy.Query<TVariables> {\n    dataId: string;\n    result: TResult;\n  }\n\n  export interface DiffOptions extends ReadOptions {\n    returnPartialData?: boolean;\n  }\n\n  export interface WatchOptions extends ReadOptions {\n    callback: WatchCallback;\n  }\n\n  export interface EvictOptions<TVariables = any>\n    extends DataProxy.Query<TVariables> {\n    rootId?: string;\n  }\n\n  export import DiffResult = DataProxy.DiffResult;\n  export import WriteQueryOptions = DataProxy.WriteQueryOptions;\n  export import WriteFragmentOptions = DataProxy.WriteFragmentOptions;\n  export import WriteDataOptions = DataProxy.WriteDataOptions;\n  export import Fragment = DataProxy.Fragment;\n}\n", "type Context = {\n  parent: Context | null;\n  slots: { [slotId: string]: any };\n}\n\n// This currentContext variable will only be used if the makeSlotClass\n// function is called, which happens only if this is the first copy of the\n// @wry/context package to be imported.\nlet currentContext: Context | null = null;\n\n// This unique internal object is used to denote the absence of a value\n// for a given Slot, and is never exposed to outside code.\nconst MISSING_VALUE: any = {};\n\nlet idCounter = 1;\n\n// Although we can't do anything about the cost of duplicated code from\n// accidentally bundling multiple copies of the @wry/context package, we can\n// avoid creating the Slot class more than once using makeSlotClass.\nconst makeSlotClass = () => class Slot<TValue> {\n  // If you have a Slot object, you can find out its slot.id, but you cannot\n  // guess the slot.id of a Slot you don't have access to, thanks to the\n  // randomized suffix.\n  public readonly id = [\n    \"slot\",\n    idCounter++,\n    Date.now(),\n    Math.random().toString(36).slice(2),\n  ].join(\":\");\n\n  public hasValue() {\n    for (let context = currentContext; context; context = context.parent) {\n      // We use the Slot object iself as a key to its value, which means the\n      // value cannot be obtained without a reference to the Slot object.\n      if (this.id in context.slots) {\n        const value = context.slots[this.id];\n        if (value === MISSING_VALUE) break;\n        if (context !== currentContext) {\n          // Cache the value in currentContext.slots so the next lookup will\n          // be faster. This caching is safe because the tree of contexts and\n          // the values of the slots are logically immutable.\n          currentContext!.slots[this.id] = value;\n        }\n        return true;\n      }\n    }\n    if (currentContext) {\n      // If a value was not found for this Slot, it's never going to be found\n      // no matter how many times we look it up, so we might as well cache\n      // the absence of the value, too.\n      currentContext.slots[this.id] = MISSING_VALUE;\n    }\n    return false;\n  }\n\n  public getValue(): TValue | undefined {\n    if (this.hasValue()) {\n      return currentContext!.slots[this.id] as TValue;\n    }\n  }\n\n  public withValue<TResult, TArgs extends any[], TThis = any>(\n    value: TValue,\n    callback: (this: TThis, ...args: TArgs) => TResult,\n    // Given the prevalence of arrow functions, specifying arguments is likely\n    // to be much more common than specifying `this`, hence this ordering:\n    args?: TArgs,\n    thisArg?: TThis,\n  ): TResult {\n    const slots = {\n      __proto__: null,\n      [this.id]: value,\n    };\n    const parent = currentContext;\n    currentContext = { parent, slots };\n    try {\n      // Function.prototype.apply allows the arguments array argument to be\n      // omitted or undefined, so args! is fine here.\n      return callback.apply(thisArg!, args!);\n    } finally {\n      currentContext = parent;\n    }\n  }\n\n  // Capture the current context and wrap a callback function so that it\n  // reestablishes the captured context when called.\n  static bind<TArgs extends any[], TResult>(\n    callback: (...args: TArgs) => TResult,\n  ) {\n    const context = currentContext;\n    return function (this: any) {\n      const saved = currentContext;\n      try {\n        currentContext = context;\n        return callback.apply(this, arguments as any);\n      } finally {\n        currentContext = saved;\n      }\n    } as typeof callback;\n  }\n\n  // Immediately run a callback function without any captured context.\n  static noContext<TResult, TArgs extends any[], TThis = any>(\n    callback: (this: TThis, ...args: TArgs) => TResult,\n    // Given the prevalence of arrow functions, specifying arguments is likely\n    // to be much more common than specifying `this`, hence this ordering:\n    args?: TArgs,\n    thisArg?: TThis,\n  ) {\n    if (currentContext) {\n      const saved = currentContext;\n      try {\n        currentContext = null;\n        // Function.prototype.apply allows the arguments array argument to be\n        // omitted or undefined, so args! is fine here.\n        return callback.apply(thisArg!, args!);\n      } finally {\n        currentContext = saved;\n      }\n    } else {\n      return callback.apply(thisArg!, args!);\n    }\n  }\n};\n\n// We store a single global implementation of the Slot class as a permanent\n// non-enumerable symbol property of the Array constructor. This obfuscation\n// does nothing to prevent access to the Slot class, but at least it ensures\n// the implementation (i.e. currentContext) cannot be tampered with, and all\n// copies of the @wry/context package (hopefully just one) will share the\n// same Slot implementation. Since the first copy of the @wry/context package\n// to be imported wins, this technique imposes a very high cost for any\n// future breaking changes to the Slot class.\nconst globalKey = \"@wry/context:Slot\";\nconst host = Array as any;\n\nexport const Slot: ReturnType<typeof makeSlotClass> = host[globalKey] || function () {\n  const Slot = makeSlotClass();\n  try {\n    Object.defineProperty(host, globalKey, {\n      value: host[globalKey] = Slot,\n      enumerable: false,\n      writable: false,\n      configurable: false,\n    });\n  } finally {\n    return Slot;\n  }\n}();\n", "import { Slot } from \"./slot\";\nexport { Slot }\nexport const { bind, noContext } = Slot;\n\n// Like global.setTimeout, except the callback runs with captured context.\nexport { setTimeoutWithContext as setTimeout };\nfunction setTimeoutWithContext(callback: () => any, delay: number) {\n  return setTimeout(bind(callback), delay);\n}\n\n// Turn any generator function into an async function (using yield instead\n// of await), with context automatically preserved across yields.\nexport function asyncFromGen<TArgs extends any[], TResult>(\n  genFn: (...args: TArgs) => IterableIterator<TResult>,\n) {\n  return function (this: any) {\n    const gen = genFn.apply(this, arguments as any);\n    const boundNext = bind(gen.next);\n    const boundThrow = bind(gen.throw!);\n    type Method = typeof boundNext | typeof boundThrow;\n\n    return new Promise<TResult>((resolve, reject) => {\n      function invoke(method: Method, argument: any) {\n        try {\n          var result = method.call(gen, argument);\n        } catch (error) {\n          return reject(error);\n        }\n        const next = result.done ? resolve : invokeNext;\n        if (isPromiseLike(result.value)) {\n          result.value.then(next, result.done ? reject : invokeThrow);\n        } else {\n          next(result.value);\n        }\n      }\n      const invokeNext = (value?: any) => invoke(boundNext, value);\n      const invokeThrow = (error: any) => invoke(boundThrow, error);\n      invokeNext();\n    });\n  } as (...args: TArgs) => Promise<TResult>;\n}\n\nfunction isPromiseLike(value: any): value is PromiseLike<any> {\n  return value && typeof value.then === \"function\";\n}\n\n// If you use the fibers npm package to implement coroutines in Node.js,\n// you should call this function at least once to ensure context management\n// remains coherent across any yields.\nconst wrappedFibers: Function[] = [];\nexport function wrapYieldingFiberMethods<F extends Function>(Fiber: F): F {\n  // There can be only one implementation of Fiber per process, so this array\n  // should never grow longer than one element.\n  if (wrappedFibers.indexOf(Fiber) < 0) {\n    const wrap = (obj: any, method: string) => {\n      const fn = obj[method];\n      obj[method] = function () {\n        return noContext(fn, arguments as any, this);\n      };\n    }\n    // These methods can yield, according to\n    // https://github.com/laverdet/node-fibers/blob/ddebed9b8ae3883e57f822e2108e6943e5c8d2a8/fibers.js#L97-L100\n    wrap(Fiber, \"yield\");\n    wrap(Fiber.prototype, \"run\");\n    wrap(Fiber.prototype, \"throwInto\");\n    wrappedFibers.push(Fiber);\n  }\n  return Fiber;\n}\n", "interface Node<K, V> {\n  key: K;\n  value: V;\n  newer: Node<K, V> | null;\n  older: Node<K, V> | null;\n}\n\nfunction defaultDispose() {}\n\nexport class Cache<K = any, V = any> {\n  private map = new Map<K, Node<K, V>>();\n  private newest: Node<K, V> | null = null;\n  private oldest: Node<K, V> | null = null;\n\n  constructor(\n    private max = Infinity,\n    public dispose: (value: V, key: K) => void = defaultDispose,\n  ) {}\n\n  public has(key: K) {\n    return this.map.has(key);\n  }\n\n  public get(key: K) {\n    const entry = this.getEntry(key);\n    return entry && entry.value;\n  }\n\n  private getEntry(key: K): Node<K, V> | void {\n    const entry = this.map.get(key);\n\n    if (entry && entry !== this.newest) {\n      const { older, newer } = entry;\n\n      if (newer) {\n        newer.older = older;\n      }\n\n      if (older) {\n        older.newer = newer;\n      }\n\n      entry.older = this.newest;\n      entry.older!.newer = entry;\n\n      entry.newer = null;\n      this.newest = entry;\n\n      if (entry === this.oldest) {\n        this.oldest = newer;\n      }\n    }\n\n    return entry;\n  }\n\n  public set(key: K, value: V) {\n    let entry = this.getEntry(key);\n    if (entry) {\n      return entry.value = value;\n    }\n\n    entry = {\n      key: key,\n      value: value,\n      newer: null,\n      older: this.newest\n    };\n\n    if (this.newest) {\n      this.newest.newer = entry;\n    }\n\n    this.newest = entry;\n    this.oldest = this.oldest || entry;\n\n    this.map.set(key, entry);\n\n    return entry.value;\n  }\n\n  public clean() {\n    while (this.oldest && this.map.size > this.max) {\n      this.delete(this.oldest.key);\n    }\n  }\n\n  public delete(key: K) {\n    const entry = this.map.get(key);\n    if (entry) {\n      if (entry === this.newest) {\n        this.newest = entry.older;\n      }\n\n      if (entry === this.oldest) {\n        this.oldest = entry.newer;\n      }\n\n      if (entry.newer) {\n        entry.newer.older = entry.older;\n      }\n\n      if (entry.older) {\n        entry.older.newer = entry.newer;\n      }\n\n      this.map.delete(key);\n      this.dispose(entry.value, key);\n\n      return true;\n    }\n\n    return false;\n  }\n}\n", "import { AnyEntry } from \"./entry\";\nimport { Slot } from \"@wry/context\";\n\nexport const parentEntrySlot = new Slot<AnyEntry>();\n\nexport {\n  bind as bindContext,\n  noContext,\n  setTimeout,\n  asyncFromGen,\n} from \"@wry/context\";\n", "import { parentEntrySlot } from \"./context\";\nimport { OptimisticWrapOptions } from \"./index\";\n\nconst reusableEmptyArray: AnyEntry[] = [];\nconst emptySetPool: Set<AnyEntry>[] = [];\nconst POOL_TARGET_SIZE = 100;\n\n// Since this package might be used browsers, we should avoid using the\n// Node built-in assert module.\nfunction assert(condition: any, optionalMessage?: string) {\n  if (! condition) {\n    throw new Error(optionalMessage || \"assertion failure\");\n  }\n}\n\n// Since exceptions are cached just like normal values, we need an efficient\n// way of representing unknown, ordinary, and exceptional values.\ntype Value<T> =\n  | []           // unknown\n  | [T]          // known value\n  | [void, any]; // known exception\n\nfunction valueIs(a: Value<any>, b: Value<any>) {\n  const len = a.length;\n  return (\n    // Unknown values are not equal to each other.\n    len > 0 &&\n    // Both values must be ordinary (or both exceptional) to be equal.\n    len === b.length &&\n    // The underlying value or exception must be the same.\n    a[len - 1] === b[len - 1]\n  );\n}\n\nfunction valueGet<T>(value: Value<T>): T {\n  switch (value.length) {\n    case 0: throw new Error(\"unknown value\");\n    case 1: return value[0];\n    case 2: throw value[1];\n  }\n}\n\nfunction valueCopy<T>(value: Value<T>): Value<T> {\n  return value.slice(0) as Value<T>;\n}\n\nexport type AnyEntry = Entry<any, any>;\n\nexport class Entry<TArgs extends any[], TValue> {\n  public static count = 0;\n\n  public subscribe: OptimisticWrapOptions<TArgs>[\"subscribe\"];\n  public unsubscribe?: () => any;\n  public reportOrphan?: (this: Entry<TArgs, TValue>) => any;\n\n  public readonly parents = new Set<AnyEntry>();\n  public readonly childValues = new Map<AnyEntry, Value<any>>();\n\n  // When this Entry has children that are dirty, this property becomes\n  // a Set containing other Entry objects, borrowed from emptySetPool.\n  // When the set becomes empty, it gets recycled back to emptySetPool.\n  public dirtyChildren: Set<AnyEntry> | null = null;\n\n  public dirty = true;\n  public recomputing = false;\n  public readonly value: Value<TValue> = [];\n\n  constructor(\n    public readonly fn: (...args: TArgs) => TValue,\n    public args: TArgs,\n  ) {\n    ++Entry.count;\n  }\n\n  // This is the most important method of the Entry API, because it\n  // determines whether the cached this.value can be returned immediately,\n  // or must be recomputed. The overall performance of the caching system\n  // depends on the truth of the following observations: (1) this.dirty is\n  // usually false, (2) this.dirtyChildren is usually null/empty, and thus\n  // (3) valueGet(this.value) is usually returned without recomputation.\n  public recompute(): TValue {\n    assert(! this.recomputing, \"already recomputing\");\n\n    if (! rememberParent(this) && maybeReportOrphan(this)) {\n      // The recipient of the entry.reportOrphan callback decided to dispose\n      // of this orphan entry by calling entry.dispose(), so we don't need to\n      // (and should not) proceed with the recomputation.\n      return void 0 as any;\n    }\n\n    return mightBeDirty(this)\n      ? reallyRecompute(this)\n      : valueGet(this.value);\n  }\n\n  public setDirty() {\n    if (this.dirty) return;\n    this.dirty = true;\n    this.value.length = 0;\n    reportDirty(this);\n    // We can go ahead and unsubscribe here, since any further dirty\n    // notifications we receive will be redundant, and unsubscribing may\n    // free up some resources, e.g. file watchers.\n    maybeUnsubscribe(this);\n  }\n\n  public dispose() {\n    forgetChildren(this).forEach(maybeReportOrphan);\n    maybeUnsubscribe(this);\n\n    // Because this entry has been kicked out of the cache (in index.js),\n    // we've lost the ability to find out if/when this entry becomes dirty,\n    // whether that happens through a subscription, because of a direct call\n    // to entry.setDirty(), or because one of its children becomes dirty.\n    // Because of this loss of future information, we have to assume the\n    // worst (that this entry might have become dirty very soon), so we must\n    // immediately mark this entry's parents as dirty. Normally we could\n    // just call entry.setDirty() rather than calling parent.setDirty() for\n    // each parent, but that would leave this entry in parent.childValues\n    // and parent.dirtyChildren, which would prevent the child from being\n    // truly forgotten.\n    this.parents.forEach(parent => {\n      parent.setDirty();\n      forgetChild(parent, this);\n    });\n  }\n}\n\nfunction rememberParent(child: AnyEntry) {\n  const parent = parentEntrySlot.getValue();\n  if (parent) {\n    child.parents.add(parent);\n\n    if (! parent.childValues.has(child)) {\n      parent.childValues.set(child, []);\n    }\n\n    if (mightBeDirty(child)) {\n      reportDirtyChild(parent, child);\n    } else {\n      reportCleanChild(parent, child);\n    }\n\n    return parent;\n  }\n}\n\nfunction reallyRecompute(entry: AnyEntry) {\n  // Since this recomputation is likely to re-remember some of this\n  // entry's children, we forget our children here but do not call\n  // maybeReportOrphan until after the recomputation finishes.\n  const originalChildren = forgetChildren(entry);\n\n  // Set entry as the parent entry while calling recomputeNewValue(entry).\n  parentEntrySlot.withValue(entry, recomputeNewValue, [entry]);\n\n  if (maybeSubscribe(entry)) {\n    // If we successfully recomputed entry.value and did not fail to\n    // (re)subscribe, then this Entry is no longer explicitly dirty.\n    setClean(entry);\n  }\n\n  // Now that we've had a chance to re-remember any children that were\n  // involved in the recomputation, we can safely report any orphan\n  // children that remain.\n  originalChildren.forEach(maybeReportOrphan);\n\n  return valueGet(entry.value);\n}\n\nfunction recomputeNewValue(entry: AnyEntry) {\n  entry.recomputing = true;\n  // Set entry.value as unknown.\n  entry.value.length = 0;\n  try {\n    // If entry.fn succeeds, entry.value will become a normal Value.\n    entry.value[0] = entry.fn.apply(null, entry.args);\n  } catch (e) {\n    // If entry.fn throws, entry.value will become exceptional.\n    entry.value[1] = e;\n  }\n  // Either way, this line is always reached.\n  entry.recomputing = false;\n}\n\nfunction mightBeDirty(entry: AnyEntry) {\n  return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);\n}\n\nfunction setClean(entry: AnyEntry) {\n  entry.dirty = false;\n\n  if (mightBeDirty(entry)) {\n    // This Entry may still have dirty children, in which case we can't\n    // let our parents know we're clean just yet.\n    return;\n  }\n\n  reportClean(entry);\n}\n\nfunction reportDirty(child: AnyEntry) {\n  child.parents.forEach(parent => reportDirtyChild(parent, child));\n}\n\nfunction reportClean(child: AnyEntry) {\n  child.parents.forEach(parent => reportCleanChild(parent, child));\n}\n\n// Let a parent Entry know that one of its children may be dirty.\nfunction reportDirtyChild(parent: AnyEntry, child: AnyEntry) {\n  // Must have called rememberParent(child) before calling\n  // reportDirtyChild(parent, child).\n  assert(parent.childValues.has(child));\n  assert(mightBeDirty(child));\n\n  if (! parent.dirtyChildren) {\n    parent.dirtyChildren = emptySetPool.pop() || new Set;\n\n  } else if (parent.dirtyChildren.has(child)) {\n    // If we already know this child is dirty, then we must have already\n    // informed our own parents that we are dirty, so we can terminate\n    // the recursion early.\n    return;\n  }\n\n  parent.dirtyChildren.add(child);\n  reportDirty(parent);\n}\n\n// Let a parent Entry know that one of its children is no longer dirty.\nfunction reportCleanChild(parent: AnyEntry, child: AnyEntry) {\n  // Must have called rememberChild(child) before calling\n  // reportCleanChild(parent, child).\n  assert(parent.childValues.has(child));\n  assert(! mightBeDirty(child));\n\n  const childValue = parent.childValues.get(child)!;\n  if (childValue.length === 0) {\n    parent.childValues.set(child, valueCopy(child.value));\n  } else if (! valueIs(childValue, child.value)) {\n    parent.setDirty();\n  }\n\n  removeDirtyChild(parent, child);\n\n  if (mightBeDirty(parent)) {\n    return;\n  }\n\n  reportClean(parent);\n}\n\nfunction removeDirtyChild(parent: AnyEntry, child: AnyEntry) {\n  const dc = parent.dirtyChildren;\n  if (dc) {\n    dc.delete(child);\n    if (dc.size === 0) {\n      if (emptySetPool.length < POOL_TARGET_SIZE) {\n        emptySetPool.push(dc);\n      }\n      parent.dirtyChildren = null;\n    }\n  }\n}\n\n// If the given entry has a reportOrphan method, and no remaining parents,\n// call entry.reportOrphan and return true iff it returns true. The\n// reportOrphan function should return true to indicate entry.dispose()\n// has been called, and the entry has been removed from any other caches\n// (see index.js for the only current example).\nfunction maybeReportOrphan(entry: AnyEntry) {\n  return entry.parents.size === 0 &&\n    typeof entry.reportOrphan === \"function\" &&\n    entry.reportOrphan() === true;\n}\n\n// Removes all children from this entry and returns an array of the\n// removed children.\nfunction forgetChildren(parent: AnyEntry) {\n  let children = reusableEmptyArray;\n\n  if (parent.childValues.size > 0) {\n    children = [];\n    parent.childValues.forEach((_value, child) => {\n      forgetChild(parent, child);\n      children.push(child);\n    });\n  }\n\n  // After we forget all our children, this.dirtyChildren must be empty\n  // and therefore must have been reset to null.\n  assert(parent.dirtyChildren === null);\n\n  return children;\n}\n\nfunction forgetChild(parent: AnyEntry, child: AnyEntry) {\n  child.parents.delete(parent);\n  parent.childValues.delete(child);\n  removeDirtyChild(parent, child);\n}\n\nfunction maybeSubscribe(entry: AnyEntry) {\n  if (typeof entry.subscribe === \"function\") {\n    try {\n      maybeUnsubscribe(entry); // Prevent double subscriptions.\n      entry.unsubscribe = entry.subscribe.apply(null, entry.args);\n    } catch (e) {\n      // If this Entry has a subscribe function and it threw an exception\n      // (or an unsubscribe function it previously returned now throws),\n      // return false to indicate that we were not able to subscribe (or\n      // unsubscribe), and this Entry should remain dirty.\n      entry.setDirty();\n      return false;\n    }\n  }\n\n  // Returning true indicates either that there was no entry.subscribe\n  // function or that it succeeded.\n  return true;\n}\n\nfunction maybeUnsubscribe(entry: AnyEntry) {\n  const { unsubscribe } = entry;\n  if (typeof unsubscribe === \"function\") {\n    entry.unsubscribe = void 0;\n    unsubscribe();\n  }\n}\n", "// A trie data structure that holds object keys weakly, yet can also hold\n// non-object keys, unlike the native `WeakMap`.\nexport class KeyTrie<K> {\n  // Since a `WeakMap` cannot hold primitive values as keys, we need a\n  // backup `Map` instance to hold primitive keys. Both `this._weakMap`\n  // and `this._strongMap` are lazily initialized.\n  private weak?: WeakMap<any, KeyTrie<K>>;\n  private strong?: Map<any, KeyTrie<K>>;\n  private data?: K;\n\n  constructor(private readonly weakness: boolean) {}\n\n  public lookup<T extends any[]>(...array: T): K {\n    return this.lookupArray(array);\n  }\n\n  public lookupArray<T extends any[]>(array: T): K {\n    let node: KeyTrie<K> = this;\n    array.forEach(key => node = node.getChildTrie(key));\n    return node.data || (node.data = Object.create(null));\n  }\n\n  private getChildTrie(key: any) {\n    const map = this.weakness && isObjRef(key)\n      ? this.weak || (this.weak = new WeakMap<any, KeyTrie<K>>())\n      : this.strong || (this.strong = new Map<any, KeyTrie<K>>());\n    let child = map.get(key);\n    if (!child) map.set(key, child = new KeyTrie<K>(this.weakness));\n    return child;\n  }\n}\n\nfunction isObjRef(value: any) {\n  switch (typeof value) {\n  case \"object\":\n    if (value === null) break;\n    // Fall through to return true...\n  case \"function\":\n    return true;\n  }\n  return false;\n}\n", "import { Cache } from \"./cache\";\nimport { Entry, AnyEntry } from \"./entry\";\nimport { parentEntrySlot } from \"./context\";\nimport { KeyTrie } from \"./key-trie\";\n\n// These helper functions are important for making optimism work with\n// asynchronous code. In order to register parent-child dependencies,\n// optimism needs to know about any currently active parent computations.\n// In ordinary synchronous code, the parent context is implicit in the\n// execution stack, but asynchronous code requires some extra guidance in\n// order to propagate context from one async task segment to the next.\nexport {\n  bindContext,\n  noContext,\n  setTimeout,\n  asyncFromGen,\n} from \"./context\";\n\n// Since the Cache uses a Map internally, any value or object reference can\n// be safely used as a key, though common types include object and string.\nexport type TCacheKey = any;\n\n// The defaultMakeCacheKey function is remarkably powerful, because it gives\n// a unique object for any shallow-identical list of arguments. If you need\n// to implement a custom makeCacheKey function, you may find it helpful to\n// delegate the final work to defaultMakeCacheKey, which is why we export it\n// here. However, you may want to avoid defaultMakeCacheKey if your runtime\n// does not support WeakMap, or you have the ability to return a string key.\n// In those cases, just write your own custom makeCacheKey functions.\nconst keyTrie = new KeyTrie<TCacheKey>(typeof WeakMap === \"function\");\nexport function defaultMakeCacheKey(...args: any[]) {\n  return keyTrie.lookupArray(args);\n}\n\n// If you're paranoid about memory leaks, or you want to avoid using WeakMap\n// under the hood, but you still need the behavior of defaultMakeCacheKey,\n// import this constructor to create your own tries.\nexport { KeyTrie }\n\nexport type OptimisticWrapperFunction<\n  TArgs extends any[],\n  TResult,\n> = ((...args: TArgs) => TResult) & {\n  // The .dirty(...) method of an optimistic function takes exactly the\n  // same parameter types as the original function.\n  dirty: (...args: TArgs) => void;\n};\n\nexport type OptimisticWrapOptions<TArgs extends any[]> = {\n  // The maximum number of cache entries that should be retained before the\n  // cache begins evicting the oldest ones.\n  max?: number;\n  // If a wrapped function is \"disposable,\" then its creator does not\n  // care about its return value, and it should be removed from the cache\n  // immediately when it no longer has any parents that depend on it.\n  disposable?: boolean;\n  // The makeCacheKey function takes the same arguments that were passed to\n  // the wrapper function and returns a single value that can be used as a key\n  // in a Map to identify the cached result.\n  makeCacheKey?: (...args: TArgs) => TCacheKey;\n  // If provided, the subscribe function should either return an unsubscribe\n  // function or return nothing.\n  subscribe?: (...args: TArgs) => (() => any) | undefined;\n};\n\nconst caches = new Set<Cache<TCacheKey, AnyEntry>>();\n\nexport function wrap<\n  TArgs extends any[],\n  TResult,\n>(\n  originalFunction: (...args: TArgs) => TResult,\n  options: OptimisticWrapOptions<TArgs> = Object.create(null),\n) {\n  const cache = new Cache<TCacheKey, Entry<TArgs, TResult>>(\n    options.max || Math.pow(2, 16),\n    entry => entry.dispose(),\n  );\n\n  const disposable = !! options.disposable;\n  const makeCacheKey = options.makeCacheKey || defaultMakeCacheKey;\n\n  function optimistic(): TResult {\n    if (disposable && ! parentEntrySlot.hasValue()) {\n      // If there's no current parent computation, and this wrapped\n      // function is disposable (meaning we don't care about entry.value,\n      // just dependency tracking), then we can short-cut everything else\n      // in this function, because entry.recompute() is going to recycle\n      // the entry object without recomputing anything, anyway.\n      return void 0 as any;\n    }\n\n    const key = makeCacheKey.apply(null, arguments as any);\n    if (key === void 0) {\n      return originalFunction.apply(null, arguments as any);\n    }\n\n    const args = Array.prototype.slice.call(arguments) as TArgs;\n\n    let entry = cache.get(key);\n    if (entry) {\n      entry.args = args;\n    } else {\n      entry = new Entry<TArgs, TResult>(originalFunction, args);\n      cache.set(key, entry);\n      entry.subscribe = options.subscribe;\n      if (disposable) {\n        entry.reportOrphan = () => cache.delete(key);\n      }\n    }\n\n    const value = entry.recompute();\n\n    // Move this entry to the front of the least-recently used queue,\n    // since we just finished computing its value.\n    cache.set(key, entry);\n\n    caches.add(cache);\n\n    // Clean up any excess entries in the cache, but only if there is no\n    // active parent entry, meaning we're not in the middle of a larger\n    // computation that might be flummoxed by the cleaning.\n    if (! parentEntrySlot.hasValue()) {\n      caches.forEach(cache => cache.clean());\n      caches.clear();\n    }\n\n    // If options.disposable is truthy, the caller of wrap is telling us\n    // they don't care about the result of entry.recompute(), so we should\n    // avoid returning the value, so it won't be accidentally used.\n    return disposable ? void 0 as any : value;\n  }\n\n  optimistic.dirty = function () {\n    const key = makeCacheKey.apply(null, arguments as any);\n    const child = key !== void 0 && cache.get(key);\n    if (child) {\n      child.setDirty();\n    }\n  };\n\n  return optimistic as OptimisticWrapperFunction<TArgs, TResult>;\n}\n", "import { isTest, IdValue } from 'apollo-utilities';\nimport { invariant } from 'ts-invariant';\n\nimport {\n  ReadStoreContext,\n  FragmentMatcherInterface,\n  PossibleTypesMap,\n  IntrospectionResultData,\n} from './types';\n\nlet haveWarned = false;\n\nfunction shouldWarn() {\n  const answer = !haveWarned;\n  /* istanbul ignore if */\n  if (!isTest()) {\n    haveWarned = true;\n  }\n  return answer;\n}\n\n/**\n * This fragment matcher is very basic and unable to match union or interface type conditions\n */\nexport class HeuristicFragmentMatcher implements FragmentMatcherInterface {\n  constructor() {\n    // do nothing\n  }\n\n  public ensureReady() {\n    return Promise.resolve();\n  }\n\n  public canBypassInit() {\n    return true; // we don't need to initialize this fragment matcher.\n  }\n\n  public match(\n    idValue: IdValue,\n    typeCondition: string,\n    context: ReadStoreContext,\n  ): boolean | 'heuristic' {\n    const obj = context.store.get(idValue.id);\n    const isRootQuery = idValue.id === 'ROOT_QUERY';\n\n    if (!obj) {\n      // https://github.com/apollographql/apollo-client/pull/3507\n      return isRootQuery;\n    }\n\n    const { __typename = isRootQuery && 'Query' } = obj;\n\n    if (!__typename) {\n      if (shouldWarn()) {\n        invariant.warn(`You're using fragments in your queries, but either don't have the addTypename:\n  true option set in Apollo Client, or you are trying to write a fragment to the store without the __typename.\n   Please turn on the addTypename option and include __typename when writing fragments so that Apollo Client\n   can accurately match fragments.`);\n        invariant.warn(\n          'Could not find __typename on Fragment ',\n          typeCondition,\n          obj,\n        );\n        invariant.warn(\n          `DEPRECATION WARNING: using fragments without __typename is unsupported behavior ` +\n            `and will be removed in future versions of Apollo client. You should fix this and set addTypename to true now.`,\n        );\n      }\n\n      return 'heuristic';\n    }\n\n    if (__typename === typeCondition) {\n      return true;\n    }\n\n    // At this point we don't know if this fragment should match or not. It's\n    // either:\n    //\n    // 1. (GOOD) A fragment on a matching interface or union.\n    // 2. (BAD) A fragment on a non-matching concrete type or interface or union.\n    //\n    // If it's 2, we don't want it to match. If it's 1, we want it to match. We\n    // can't tell the difference, so we warn the user, but still try to match\n    // it (for backwards compatibility reasons). This unfortunately means that\n    // using the `HeuristicFragmentMatcher` with unions and interfaces is\n    // very unreliable. This will be addressed in a future major version of\n    // Apollo Client, but for now the recommendation is to use the\n    // `IntrospectionFragmentMatcher` when working with unions/interfaces.\n\n    if (shouldWarn()) {\n      invariant.error(\n        'You are using the simple (heuristic) fragment matcher, but your ' +\n          'queries contain union or interface types. Apollo Client will not be ' +\n          'able to accurately map fragments. To make this error go away, use ' +\n          'the `IntrospectionFragmentMatcher` as described in the docs: ' +\n          'https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher',\n      );\n    }\n\n    return 'heuristic';\n  }\n}\n\nexport class IntrospectionFragmentMatcher implements FragmentMatcherInterface {\n  private isReady: boolean;\n  private possibleTypesMap: PossibleTypesMap;\n\n  constructor(options?: {\n    introspectionQueryResultData?: IntrospectionResultData;\n  }) {\n    if (options && options.introspectionQueryResultData) {\n      this.possibleTypesMap = this.parseIntrospectionResult(\n        options.introspectionQueryResultData,\n      );\n      this.isReady = true;\n    } else {\n      this.isReady = false;\n    }\n\n    this.match = this.match.bind(this);\n  }\n\n  public match(\n    idValue: IdValue,\n    typeCondition: string,\n    context: ReadStoreContext,\n  ) {\n    invariant(\n      this.isReady,\n      'FragmentMatcher.match() was called before FragmentMatcher.init()',\n    );\n\n    const obj = context.store.get(idValue.id);\n    const isRootQuery = idValue.id === 'ROOT_QUERY';\n\n    if (!obj) {\n      // https://github.com/apollographql/apollo-client/pull/4620\n      return isRootQuery;\n    }\n\n    const { __typename = isRootQuery && 'Query' } = obj;\n\n    invariant(\n      __typename,\n      `Cannot match fragment because __typename property is missing: ${JSON.stringify(\n        obj,\n      )}`,\n    );\n\n    if (__typename === typeCondition) {\n      return true;\n    }\n\n    const implementingTypes = this.possibleTypesMap[typeCondition];\n    if (\n      __typename &&\n      implementingTypes &&\n      implementingTypes.indexOf(__typename) > -1\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private parseIntrospectionResult(\n    introspectionResultData: IntrospectionResultData,\n  ): PossibleTypesMap {\n    const typeMap: PossibleTypesMap = {};\n    introspectionResultData.__schema.types.forEach(type => {\n      if (type.kind === 'UNION' || type.kind === 'INTERFACE') {\n        typeMap[type.name] = type.possibleTypes.map(\n          implementingType => implementingType.name,\n        );\n      }\n    });\n    return typeMap;\n  }\n}\n", "import { NormalizedCache, NormalizedCacheObject, StoreObject } from './types';\nimport { wrap, OptimisticWrapperFunction } from 'optimism';\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nexport class DepTrackingCache implements NormalizedCache {\n  // Wrapper function produced by the optimism library, used to depend on\n  // dataId strings, for easy invalidation of specific IDs.\n  private depend: OptimisticWrapperFunction<[string], StoreObject | undefined>;\n\n  constructor(private data: NormalizedCacheObject = Object.create(null)) {\n    this.depend = wrap((dataId: string) => this.data[dataId], {\n      disposable: true,\n      makeCacheKey(dataId: string) {\n        return dataId;\n      },\n    });\n  }\n\n  public toObject(): NormalizedCacheObject {\n    return this.data;\n  }\n\n  public get(dataId: string): StoreObject {\n    this.depend(dataId);\n    return this.data[dataId]!;\n  }\n\n  public set(dataId: string, value?: StoreObject) {\n    const oldValue = this.data[dataId];\n    if (value !== oldValue) {\n      this.data[dataId] = value;\n      this.depend.dirty(dataId);\n    }\n  }\n\n  public delete(dataId: string): void {\n    if (hasOwn.call(this.data, dataId)) {\n      delete this.data[dataId];\n      this.depend.dirty(dataId);\n    }\n  }\n\n  public clear(): void {\n    this.replace(null);\n  }\n\n  public replace(newData: NormalizedCacheObject | null): void {\n    if (newData) {\n      Object.keys(newData).forEach(dataId => {\n        this.set(dataId, newData[dataId]);\n      });\n      Object.keys(this.data).forEach(dataId => {\n        if (!hasOwn.call(newData, dataId)) {\n          this.delete(dataId);\n        }\n      });\n    } else {\n      Object.keys(this.data).forEach(dataId => {\n        this.delete(dataId);\n      });\n    }\n  }\n}\n\nexport function defaultNormalizedCacheFactory(\n  seed?: NormalizedCacheObject,\n): NormalizedCache {\n  return new DepTrackingCache(seed);\n}\n", "import {\n  argumentsObjectFromField,\n  assign,\n  canUseWeakMap,\n  createFragmentMap,\n  DirectiveInfo,\n  FragmentMap,\n  getDefaultValues,\n  getDirectiveInfoFromField,\n  getFragmentDefinitions,\n  getMainDefinition,\n  getQueryDefinition,\n  getStoreKeyName,\n  IdValue,\n  isEqual,\n  isField,\n  isIdValue,\n  isInlineFragment,\n  isJsonValue,\n  maybeDeepFreeze,\n  mergeDeepArray,\n  resultKeyNameFromField,\n  shouldInclude,\n  StoreValue,\n  toIdValue,\n} from 'apollo-utilities';\n\nimport { Cache } from 'apollo-cache';\n\nimport {\n  ReadStoreContext,\n  DiffQueryAgainstStoreOptions,\n  ReadQueryOptions,\n  StoreObject,\n} from './types';\n\nimport {\n  DocumentNode,\n  FieldNode,\n  FragmentDefinitionNode,\n  InlineFragmentNode,\n  SelectionSetNode,\n} from 'graphql';\n\nimport { wrap, KeyTrie } from 'optimism';\nimport { DepTrackingCache } from './depTrackingCache';\nimport { invariant, InvariantError } from 'ts-invariant';\n\nexport type VariableMap = { [name: string]: any };\n\nexport type FragmentMatcher = (\n  rootValue: any,\n  typeCondition: string,\n  context: ReadStoreContext,\n) => boolean | 'heuristic';\n\ntype ExecContext = {\n  query: DocumentNode;\n  fragmentMap: FragmentMap;\n  contextValue: ReadStoreContext;\n  variableValues: VariableMap;\n  fragmentMatcher: FragmentMatcher;\n};\n\ntype ExecInfo = {\n  resultKey: string;\n  directives: DirectiveInfo;\n};\n\nexport type ExecResultMissingField = {\n  object: StoreObject;\n  fieldName: string;\n  tolerable: boolean;\n};\n\nexport type ExecResult<R = any> = {\n  result: R;\n  // Empty array if no missing fields encountered while computing result.\n  missing?: ExecResultMissingField[];\n};\n\ntype ExecStoreQueryOptions = {\n  query: DocumentNode;\n  rootValue: IdValue;\n  contextValue: ReadStoreContext;\n  variableValues: VariableMap;\n  // Default matcher always matches all fragments\n  fragmentMatcher?: FragmentMatcher;\n};\n\ntype ExecSelectionSetOptions = {\n  selectionSet: SelectionSetNode;\n  rootValue: any;\n  execContext: ExecContext;\n};\n\ntype ExecSubSelectedArrayOptions = {\n  field: FieldNode;\n  array: any[];\n  execContext: ExecContext;\n};\n\nexport interface StoreReaderConfig {\n  cacheKeyRoot?: KeyTrie<object>;\n  freezeResults?: boolean;\n}\n\nexport class StoreReader {\n  private freezeResults: boolean;\n\n  constructor({\n    cacheKeyRoot = new KeyTrie<object>(canUseWeakMap),\n    freezeResults = false,\n  }: StoreReaderConfig = {}) {\n    const {\n      executeStoreQuery,\n      executeSelectionSet,\n      executeSubSelectedArray,\n    } = this;\n\n    this.freezeResults = freezeResults;\n\n    this.executeStoreQuery = wrap((options: ExecStoreQueryOptions) => {\n      return executeStoreQuery.call(this, options);\n    }, {\n      makeCacheKey({\n        query,\n        rootValue,\n        contextValue,\n        variableValues,\n        fragmentMatcher,\n      }: ExecStoreQueryOptions) {\n        // The result of executeStoreQuery can be safely cached only if the\n        // underlying store is capable of tracking dependencies and invalidating\n        // the cache when relevant data have changed.\n        if (contextValue.store instanceof DepTrackingCache) {\n          return cacheKeyRoot.lookup(\n            contextValue.store,\n            query,\n            fragmentMatcher,\n            JSON.stringify(variableValues),\n            rootValue.id,\n          );\n        }\n      }\n    });\n\n    this.executeSelectionSet = wrap((options: ExecSelectionSetOptions) => {\n      return executeSelectionSet.call(this, options);\n    }, {\n      makeCacheKey({\n        selectionSet,\n        rootValue,\n        execContext,\n      }: ExecSelectionSetOptions) {\n        if (execContext.contextValue.store instanceof DepTrackingCache) {\n          return cacheKeyRoot.lookup(\n            execContext.contextValue.store,\n            selectionSet,\n            execContext.fragmentMatcher,\n            JSON.stringify(execContext.variableValues),\n            rootValue.id,\n          );\n        }\n      }\n    });\n\n    this.executeSubSelectedArray = wrap((options: ExecSubSelectedArrayOptions) => {\n      return executeSubSelectedArray.call(this, options);\n    }, {\n      makeCacheKey({ field, array, execContext }) {\n        if (execContext.contextValue.store instanceof DepTrackingCache) {\n          return cacheKeyRoot.lookup(\n            execContext.contextValue.store,\n            field,\n            array,\n            JSON.stringify(execContext.variableValues),\n          );\n        }\n      }\n    });\n  }\n\n  /**\n   * Resolves the result of a query solely from the store (i.e. never hits the server).\n   *\n   * @param {Store} store The {@link NormalizedCache} used by Apollo for the `data` portion of the\n   * store.\n   *\n   * @param {DocumentNode} query The query document to resolve from the data available in the store.\n   *\n   * @param {Object} [variables] A map from the name of a variable to its value. These variables can\n   * be referenced by the query document.\n   *\n   * @param {any} previousResult The previous result returned by this function for the same query.\n   * If nothing in the store changed since that previous result then values from the previous result\n   * will be returned to preserve referential equality.\n   */\n  public readQueryFromStore<QueryType>(\n    options: ReadQueryOptions,\n  ): QueryType | undefined {\n    return this.diffQueryAgainstStore<QueryType>({\n      ...options,\n      returnPartialData: false,\n    }).result;\n  }\n\n  /**\n   * Given a store and a query, return as much of the result as possible and\n   * identify if any data was missing from the store.\n   * @param  {DocumentNode} query A parsed GraphQL query document\n   * @param  {Store} store The Apollo Client store object\n   * @param  {any} previousResult The previous result returned by this function for the same query\n   * @return {result: Object, complete: [boolean]}\n   */\n  public diffQueryAgainstStore<T>({\n    store,\n    query,\n    variables,\n    previousResult,\n    returnPartialData = true,\n    rootId = 'ROOT_QUERY',\n    fragmentMatcherFunction,\n    config,\n  }: DiffQueryAgainstStoreOptions): Cache.DiffResult<T> {\n    // Throw the right validation error by trying to find a query in the document\n    const queryDefinition = getQueryDefinition(query);\n\n    variables = assign({}, getDefaultValues(queryDefinition), variables);\n\n    const context: ReadStoreContext = {\n      // Global settings\n      store,\n      dataIdFromObject: config && config.dataIdFromObject,\n      cacheRedirects: (config && config.cacheRedirects) || {},\n    };\n\n    const execResult = this.executeStoreQuery({\n      query,\n      rootValue: {\n        type: 'id',\n        id: rootId,\n        generated: true,\n        typename: 'Query',\n      },\n      contextValue: context,\n      variableValues: variables,\n      fragmentMatcher: fragmentMatcherFunction,\n    });\n\n    const hasMissingFields =\n      execResult.missing && execResult.missing.length > 0;\n\n    if (hasMissingFields && ! returnPartialData) {\n      execResult.missing!.forEach(info => {\n        if (info.tolerable) return;\n        throw new InvariantError(\n          `Can't find field ${info.fieldName} on object ${JSON.stringify(\n            info.object,\n            null,\n            2,\n          )}.`,\n        );\n      });\n    }\n\n    if (previousResult) {\n      if (isEqual(previousResult, execResult.result)) {\n        execResult.result = previousResult;\n      }\n    }\n\n    return {\n      result: execResult.result,\n      complete: !hasMissingFields,\n    };\n  }\n\n  /**\n   * Based on graphql function from graphql-js:\n   *\n   * graphql(\n   *   schema: GraphQLSchema,\n   *   requestString: string,\n   *   rootValue?: ?any,\n   *   contextValue?: ?any,\n   *   variableValues?: ?{[key: string]: any},\n   *   operationName?: ?string\n   * ): Promise<GraphQLResult>\n   *\n   * The default export as of graphql-anywhere is sync as of 4.0,\n   * but below is an exported alternative that is async.\n   * In the 5.0 version, this will be the only export again\n   * and it will be async\n   *\n   */\n  private executeStoreQuery({\n    query,\n    rootValue,\n    contextValue,\n    variableValues,\n    // Default matcher always matches all fragments\n    fragmentMatcher = defaultFragmentMatcher,\n  }: ExecStoreQueryOptions): ExecResult {\n    const mainDefinition = getMainDefinition(query);\n    const fragments = getFragmentDefinitions(query);\n    const fragmentMap = createFragmentMap(fragments);\n    const execContext: ExecContext = {\n      query,\n      fragmentMap,\n      contextValue,\n      variableValues,\n      fragmentMatcher,\n    };\n\n    return this.executeSelectionSet({\n      selectionSet: mainDefinition.selectionSet,\n      rootValue,\n      execContext,\n    });\n  }\n\n  private executeSelectionSet({\n    selectionSet,\n    rootValue,\n    execContext,\n  }: ExecSelectionSetOptions): ExecResult {\n    const { fragmentMap, contextValue, variableValues: variables } = execContext;\n    const finalResult: ExecResult = { result: null };\n\n    const objectsToMerge: { [key: string]: any }[] = [];\n\n    const object: StoreObject = contextValue.store.get(rootValue.id);\n\n    const typename =\n      (object && object.__typename) ||\n      (rootValue.id === 'ROOT_QUERY' && 'Query') ||\n      void 0;\n\n    function handleMissing<T>(result: ExecResult<T>): T {\n      if (result.missing) {\n        finalResult.missing = finalResult.missing || [];\n        finalResult.missing.push(...result.missing);\n      }\n      return result.result;\n    }\n\n    selectionSet.selections.forEach(selection => {\n      if (!shouldInclude(selection, variables)) {\n        // Skip this entirely\n        return;\n      }\n\n      if (isField(selection)) {\n        const fieldResult = handleMissing(\n          this.executeField(object, typename, selection, execContext),\n        );\n\n        if (typeof fieldResult !== 'undefined') {\n          objectsToMerge.push({\n            [resultKeyNameFromField(selection)]: fieldResult,\n          });\n        }\n\n      } else {\n        let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n        if (isInlineFragment(selection)) {\n          fragment = selection;\n        } else {\n          // This is a named fragment\n          fragment = fragmentMap[selection.name.value];\n\n          if (!fragment) {\n            throw new InvariantError(`No fragment named ${selection.name.value}`);\n          }\n        }\n\n        const typeCondition =\n          fragment.typeCondition && fragment.typeCondition.name.value;\n\n        const match =\n          !typeCondition ||\n          execContext.fragmentMatcher(rootValue, typeCondition, contextValue);\n\n        if (match) {\n          let fragmentExecResult = this.executeSelectionSet({\n            selectionSet: fragment.selectionSet,\n            rootValue,\n            execContext,\n          });\n\n          if (match === 'heuristic' && fragmentExecResult.missing) {\n            fragmentExecResult = {\n              ...fragmentExecResult,\n              missing: fragmentExecResult.missing.map(info => {\n                return { ...info, tolerable: true };\n              }),\n            };\n          }\n\n          objectsToMerge.push(handleMissing(fragmentExecResult));\n        }\n      }\n    });\n\n    // Perform a single merge at the end so that we can avoid making more\n    // defensive shallow copies than necessary.\n    finalResult.result = mergeDeepArray(objectsToMerge);\n\n    if (this.freezeResults && process.env.NODE_ENV !== 'production') {\n      Object.freeze(finalResult.result);\n    }\n\n    return finalResult;\n  }\n\n  private executeField(\n    object: StoreObject,\n    typename: string | void,\n    field: FieldNode,\n    execContext: ExecContext,\n  ): ExecResult {\n    const { variableValues: variables, contextValue } = execContext;\n    const fieldName = field.name.value;\n    const args = argumentsObjectFromField(field, variables);\n\n    const info: ExecInfo = {\n      resultKey: resultKeyNameFromField(field),\n      directives: getDirectiveInfoFromField(field, variables),\n    };\n\n    const readStoreResult = readStoreResolver(\n      object,\n      typename,\n      fieldName,\n      args,\n      contextValue,\n      info,\n    );\n\n    if (Array.isArray(readStoreResult.result)) {\n      return this.combineExecResults(\n        readStoreResult,\n        this.executeSubSelectedArray({\n          field,\n          array: readStoreResult.result,\n          execContext,\n        }),\n      );\n    }\n\n    // Handle all scalar types here\n    if (!field.selectionSet) {\n      assertSelectionSetForIdValue(field, readStoreResult.result);\n      if (this.freezeResults && process.env.NODE_ENV !== 'production') {\n        maybeDeepFreeze(readStoreResult);\n      }\n      return readStoreResult;\n    }\n\n    // From here down, the field has a selection set, which means it's trying to\n    // query a GraphQLObjectType\n    if (readStoreResult.result == null) {\n      // Basically any field in a GraphQL response can be null, or missing\n      return readStoreResult;\n    }\n\n    // Returned value is an object, and the query has a sub-selection. Recurse.\n    return this.combineExecResults(\n      readStoreResult,\n      this.executeSelectionSet({\n        selectionSet: field.selectionSet,\n        rootValue: readStoreResult.result,\n        execContext,\n      }),\n    );\n  }\n\n  private combineExecResults<T>(\n    ...execResults: ExecResult<T>[]\n  ): ExecResult<T> {\n    let missing: ExecResultMissingField[] | undefined;\n    execResults.forEach(execResult => {\n      if (execResult.missing) {\n        missing = missing || [];\n        missing.push(...execResult.missing);\n      }\n    });\n    return {\n      result: execResults.pop()!.result,\n      missing,\n    };\n  }\n\n  private executeSubSelectedArray({\n    field,\n    array,\n    execContext,\n  }: ExecSubSelectedArrayOptions): ExecResult {\n    let missing: ExecResultMissingField[] | undefined;\n\n    function handleMissing<T>(childResult: ExecResult<T>): T {\n      if (childResult.missing) {\n        missing = missing || [];\n        missing.push(...childResult.missing);\n      }\n\n      return childResult.result;\n    }\n\n    array = array.map(item => {\n      // null value in array\n      if (item === null) {\n        return null;\n      }\n\n      // This is a nested array, recurse\n      if (Array.isArray(item)) {\n        return handleMissing(this.executeSubSelectedArray({\n          field,\n          array: item,\n          execContext,\n        }));\n      }\n\n      // This is an object, run the selection set on it\n      if (field.selectionSet) {\n        return handleMissing(this.executeSelectionSet({\n          selectionSet: field.selectionSet,\n          rootValue: item,\n          execContext,\n        }));\n      }\n\n      assertSelectionSetForIdValue(field, item);\n\n      return item;\n    });\n\n    if (this.freezeResults && process.env.NODE_ENV !== 'production') {\n      Object.freeze(array);\n    }\n\n    return { result: array, missing };\n  }\n}\n\nfunction assertSelectionSetForIdValue(\n  field: FieldNode,\n  value: any,\n) {\n  if (!field.selectionSet && isIdValue(value)) {\n    throw new InvariantError(\n      `Missing selection set for object of type ${\n        value.typename\n      } returned for query field ${field.name.value}`\n    );\n  }\n}\n\nfunction defaultFragmentMatcher() {\n  return true;\n}\n\nexport function assertIdValue(idValue: IdValue) {\n  invariant(isIdValue(idValue), `\\\nEncountered a sub-selection on the query, but the store doesn't have \\\nan object reference. This should never happen during normal use unless you have custom code \\\nthat is directly manipulating the store; please file an issue.`);\n}\n\nfunction readStoreResolver(\n  object: StoreObject,\n  typename: string | void,\n  fieldName: string,\n  args: any,\n  context: ReadStoreContext,\n  { resultKey, directives }: ExecInfo,\n): ExecResult<StoreValue> {\n  let storeKeyName = fieldName;\n  if (args || directives) {\n    // We happen to know here that getStoreKeyName returns its first\n    // argument unmodified if there are no args or directives, so we can\n    // avoid calling the function at all in that case, as a small but\n    // important optimization to this frequently executed code.\n    storeKeyName = getStoreKeyName(storeKeyName, args, directives);\n  }\n\n  let fieldValue: StoreValue | void = void 0;\n\n  if (object) {\n    fieldValue = object[storeKeyName];\n\n    if (\n      typeof fieldValue === 'undefined' &&\n      context.cacheRedirects &&\n      typeof typename === 'string'\n    ) {\n      // Look for the type in the custom resolver map\n      const type = context.cacheRedirects[typename];\n      if (type) {\n        // Look for the field in the custom resolver map\n        const resolver = type[fieldName];\n        if (resolver) {\n          fieldValue = resolver(object, args, {\n            getCacheKey(storeObj: StoreObject) {\n              const id = context.dataIdFromObject!(storeObj);\n              return id && toIdValue({\n                id,\n                typename: storeObj.__typename,\n              });\n            },\n          });\n        }\n      }\n    }\n  }\n\n  if (typeof fieldValue === 'undefined') {\n    return {\n      result: fieldValue,\n      missing: [{\n        object,\n        fieldName: storeKeyName,\n        tolerable: false,\n      }],\n    };\n  }\n\n  if (isJsonValue(fieldValue)) {\n    fieldValue = fieldValue.json;\n  }\n\n  return {\n    result: fieldValue,\n  };\n}\n", "import { NormalizedCache, NormalizedCacheObject, StoreObject } from './types';\n\nexport class ObjectCache implements NormalizedCache {\n  constructor(protected data: NormalizedCacheObject = Object.create(null)) {}\n\n  public toObject() {\n    return this.data;\n  }\n\n  public get(dataId: string) {\n    return this.data[dataId]!;\n  }\n\n  public set(dataId: string, value: StoreObject) {\n    this.data[dataId] = value;\n  }\n\n  public delete(dataId: string) {\n    this.data[dataId] = void 0;\n  }\n\n  public clear() {\n    this.data = Object.create(null);\n  }\n\n  public replace(newData: NormalizedCacheObject) {\n    this.data = newData || Object.create(null);\n  }\n}\n\nexport function defaultNormalizedCacheFactory(\n  seed?: NormalizedCacheObject,\n): NormalizedCache {\n  return new ObjectCache(seed);\n}\n", "import {\n  SelectionSetNode,\n  FieldNode,\n  DocumentNode,\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n} from 'graphql';\nimport { FragmentMatcher } from './readFromStore';\n\nimport {\n  assign,\n  createFragmentMap,\n  FragmentMap,\n  getDefaultValues,\n  getFragmentDefinitions,\n  getOperationDefinition,\n  IdValue,\n  isField,\n  isIdValue,\n  isInlineFragment,\n  isProduction,\n  resultKeyNameFromField,\n  shouldInclude,\n  storeKeyNameFromField,\n  StoreValue,\n  toIdValue,\n  isEqual,\n} from 'apollo-utilities';\n\nimport { invariant } from 'ts-invariant';\n\nimport { ObjectCache } from './objectCache';\nimport { defaultNormalizedCacheFactory } from './depTrackingCache';\n\nimport {\n  IdGetter,\n  NormalizedCache,\n  ReadStoreContext,\n  StoreObject,\n} from './types';\n\nexport class WriteError extends Error {\n  public type = 'WriteError';\n}\n\nexport function enhanceErrorWithDocument(error: Error, document: DocumentNode) {\n  // XXX A bit hacky maybe ...\n  const enhancedError = new WriteError(\n    `Error writing result to store for query:\\n ${JSON.stringify(document)}`,\n  );\n  enhancedError.message += '\\n' + error.message;\n  enhancedError.stack = error.stack;\n  return enhancedError;\n}\n\nexport type WriteContext = {\n  readonly store: NormalizedCache;\n  readonly processedData?: { [x: string]: FieldNode[] };\n  readonly variables?: any;\n  readonly dataIdFromObject?: IdGetter;\n  readonly fragmentMap?: FragmentMap;\n  readonly fragmentMatcherFunction?: FragmentMatcher;\n};\n\nexport class StoreWriter {\n  /**\n   * Writes the result of a query to the store.\n   *\n   * @param result The result object returned for the query document.\n   *\n   * @param query The query document whose result we are writing to the store.\n   *\n   * @param store The {@link NormalizedCache} used by Apollo for the `data` portion of the store.\n   *\n   * @param variables A map from the name of a variable to its value. These variables can be\n   * referenced by the query document.\n   *\n   * @param dataIdFromObject A function that returns an object identifier given a particular result\n   * object. See the store documentation for details and an example of this function.\n   *\n   * @param fragmentMatcherFunction A function to use for matching fragment conditions in GraphQL documents\n   */\n  public writeQueryToStore({\n    query,\n    result,\n    store = defaultNormalizedCacheFactory(),\n    variables,\n    dataIdFromObject,\n    fragmentMatcherFunction,\n  }: {\n    query: DocumentNode;\n    result: Object;\n    store?: NormalizedCache;\n    variables?: Object;\n    dataIdFromObject?: IdGetter;\n    fragmentMatcherFunction?: FragmentMatcher;\n  }): NormalizedCache {\n    return this.writeResultToStore({\n      dataId: 'ROOT_QUERY',\n      result,\n      document: query,\n      store,\n      variables,\n      dataIdFromObject,\n      fragmentMatcherFunction,\n    });\n  }\n\n  public writeResultToStore({\n    dataId,\n    result,\n    document,\n    store = defaultNormalizedCacheFactory(),\n    variables,\n    dataIdFromObject,\n    fragmentMatcherFunction,\n  }: {\n    dataId: string;\n    result: any;\n    document: DocumentNode;\n    store?: NormalizedCache;\n    variables?: Object;\n    dataIdFromObject?: IdGetter;\n    fragmentMatcherFunction?: FragmentMatcher;\n  }): NormalizedCache {\n    // XXX TODO REFACTOR: this is a temporary workaround until query normalization is made to work with documents.\n    const operationDefinition = getOperationDefinition(document)!;\n\n    try {\n      return this.writeSelectionSetToStore({\n        result,\n        dataId,\n        selectionSet: operationDefinition.selectionSet,\n        context: {\n          store,\n          processedData: {},\n          variables: assign(\n            {},\n            getDefaultValues(operationDefinition),\n            variables,\n          ),\n          dataIdFromObject,\n          fragmentMap: createFragmentMap(getFragmentDefinitions(document)),\n          fragmentMatcherFunction,\n        },\n      });\n    } catch (e) {\n      throw enhanceErrorWithDocument(e, document);\n    }\n  }\n\n  public writeSelectionSetToStore({\n    result,\n    dataId,\n    selectionSet,\n    context,\n  }: {\n    dataId: string;\n    result: any;\n    selectionSet: SelectionSetNode;\n    context: WriteContext;\n  }): NormalizedCache {\n    const { variables, store, fragmentMap } = context;\n\n    selectionSet.selections.forEach(selection => {\n      if (!shouldInclude(selection, variables)) {\n        return;\n      }\n\n      if (isField(selection)) {\n        const resultFieldKey: string = resultKeyNameFromField(selection);\n        const value: any = result[resultFieldKey];\n\n        if (typeof value !== 'undefined') {\n          this.writeFieldToStore({\n            dataId,\n            value,\n            field: selection,\n            context,\n          });\n        } else {\n          let isDefered = false;\n          let isClient = false;\n          if (selection.directives && selection.directives.length) {\n            // If this is a defered field we don't need to throw / warn.\n            isDefered = selection.directives.some(\n              directive => directive.name && directive.name.value === 'defer',\n            );\n\n            // When using the @client directive, it might be desirable in\n            // some cases to want to write a selection set to the store,\n            // without having all of the selection set values available.\n            // This is because the @client field values might have already\n            // been written to the cache separately (e.g. via Apollo\n            // Cache's `writeData` capabilities). Because of this, we'll\n            // skip the missing field warning for fields with @client\n            // directives.\n            isClient = selection.directives.some(\n              directive => directive.name && directive.name.value === 'client',\n            );\n          }\n\n          if (!isDefered && !isClient && context.fragmentMatcherFunction) {\n            // XXX We'd like to throw an error, but for backwards compatibility's sake\n            // we just print a warning for the time being.\n            //throw new WriteError(`Missing field ${resultFieldKey} in ${JSON.stringify(result, null, 2).substring(0, 100)}`);\n            invariant.warn(\n              `Missing field ${resultFieldKey} in ${JSON.stringify(\n                result,\n                null,\n                2,\n              ).substring(0, 100)}`,\n            );\n          }\n        }\n      } else {\n        // This is not a field, so it must be a fragment, either inline or named\n        let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n        if (isInlineFragment(selection)) {\n          fragment = selection;\n        } else {\n          // Named fragment\n          fragment = (fragmentMap || {})[selection.name.value];\n          invariant(fragment, `No fragment named ${selection.name.value}.`);\n        }\n\n        let matches = true;\n        if (context.fragmentMatcherFunction && fragment.typeCondition) {\n          // TODO we need to rewrite the fragment matchers for this to work properly and efficiently\n          // Right now we have to pretend that we're passing in an idValue and that there's a store\n          // on the context.\n          const id = dataId || 'self';\n          const idValue = toIdValue({ id, typename: undefined });\n          const fakeContext: ReadStoreContext = {\n            // NOTE: fakeContext always uses ObjectCache\n            // since this is only to ensure the return value of 'matches'\n            store: new ObjectCache({ [id]: result }),\n            cacheRedirects: {},\n          };\n          const match = context.fragmentMatcherFunction(\n            idValue,\n            fragment.typeCondition.name.value,\n            fakeContext,\n          );\n          if (!isProduction() && match === 'heuristic') {\n            invariant.error('WARNING: heuristic fragment matching going on!');\n          }\n          matches = !!match;\n        }\n\n        if (matches) {\n          this.writeSelectionSetToStore({\n            result,\n            selectionSet: fragment.selectionSet,\n            dataId,\n            context,\n          });\n        }\n      }\n    });\n\n    return store;\n  }\n\n  private writeFieldToStore({\n    field,\n    value,\n    dataId,\n    context,\n  }: {\n    field: FieldNode;\n    value: any;\n    dataId: string;\n    context: WriteContext;\n  }) {\n    const { variables, dataIdFromObject, store } = context;\n\n    let storeValue: StoreValue;\n    let storeObject: StoreObject;\n\n    const storeFieldName: string = storeKeyNameFromField(field, variables);\n\n    // If this is a scalar value...\n    if (!field.selectionSet || value === null) {\n      storeValue =\n        value != null && typeof value === 'object'\n          ? // If the scalar value is a JSON blob, we have to \"escape\" it so it can\u2019t pretend to be\n            // an id.\n            { type: 'json', json: value }\n          : // Otherwise, just store the scalar directly in the store.\n            value;\n    } else if (Array.isArray(value)) {\n      const generatedId = `${dataId}.${storeFieldName}`;\n\n      storeValue = this.processArrayValue(\n        value,\n        generatedId,\n        field.selectionSet,\n        context,\n      );\n    } else {\n      // It's an object\n      let valueDataId = `${dataId}.${storeFieldName}`;\n      let generated = true;\n\n      // We only prepend the '$' if the valueDataId isn't already a generated\n      // id.\n      if (!isGeneratedId(valueDataId)) {\n        valueDataId = '$' + valueDataId;\n      }\n\n      if (dataIdFromObject) {\n        const semanticId = dataIdFromObject(value);\n\n        // We throw an error if the first character of the id is '$. This is\n        // because we use that character to designate an Apollo-generated id\n        // and we use the distinction between user-desiginated and application-provided\n        // ids when managing overwrites.\n        invariant(\n          !semanticId || !isGeneratedId(semanticId),\n          'IDs returned by dataIdFromObject cannot begin with the \"$\" character.',\n        );\n\n        if (\n          semanticId ||\n          (typeof semanticId === 'number' && semanticId === 0)\n        ) {\n          valueDataId = semanticId;\n          generated = false;\n        }\n      }\n\n      if (!isDataProcessed(valueDataId, field, context.processedData)) {\n        this.writeSelectionSetToStore({\n          dataId: valueDataId,\n          result: value,\n          selectionSet: field.selectionSet,\n          context,\n        });\n      }\n\n      // We take the id and escape it (i.e. wrap it with an enclosing object).\n      // This allows us to distinguish IDs from normal scalars.\n      const typename = value.__typename;\n      storeValue = toIdValue({ id: valueDataId, typename }, generated);\n\n      // check if there was a generated id at the location where we're\n      // about to place this new id. If there was, we have to merge the\n      // data from that id with the data we're about to write in the store.\n      storeObject = store.get(dataId);\n      const escapedId =\n        storeObject && (storeObject[storeFieldName] as IdValue | undefined);\n      if (escapedId !== storeValue && isIdValue(escapedId)) {\n        const hadTypename = escapedId.typename !== undefined;\n        const hasTypename = typename !== undefined;\n        const typenameChanged =\n          hadTypename && hasTypename && escapedId.typename !== typename;\n\n        // If there is already a real id in the store and the current id we\n        // are dealing with is generated, we throw an error.\n        // One exception we allow is when the typename has changed, which occurs\n        // when schema defines a union, both with and without an ID in the same place.\n        // checks if we \"lost\" the read id\n        invariant(\n          !generated || escapedId.generated || typenameChanged,\n          `Store error: the application attempted to write an object with no provided id but the store already contains an id of ${\n            escapedId.id\n          } for this object. The selectionSet that was trying to be written is:\\n${\n            JSON.stringify(field)\n          }`,\n        );\n\n        // checks if we \"lost\" the typename\n        invariant(\n          !hadTypename || hasTypename,\n          `Store error: the application attempted to write an object with no provided typename but the store already contains an object with typename of ${\n            escapedId.typename\n          } for the object of id ${escapedId.id}. The selectionSet that was trying to be written is:\\n${\n            JSON.stringify(field)\n          }`,\n        );\n\n        if (escapedId.generated) {\n          // We should only merge if it's an object of the same type,\n          // otherwise we should delete the generated object\n          if (typenameChanged) {\n            // Only delete the generated object when the old object was\n            // inlined, and the new object is not. This is indicated by\n            // the old id being generated, and the new id being real.\n            if (!generated) {\n              store.delete(escapedId.id);\n            }\n          } else {\n            mergeWithGenerated(escapedId.id, (storeValue as IdValue).id, store);\n          }\n        }\n      }\n    }\n\n    storeObject = store.get(dataId);\n    if (!storeObject || !isEqual(storeValue, storeObject[storeFieldName])) {\n      store.set(dataId, {\n        ...storeObject,\n        [storeFieldName]: storeValue,\n      });\n    }\n  }\n\n  private processArrayValue(\n    value: any[],\n    generatedId: string,\n    selectionSet: SelectionSetNode,\n    context: WriteContext,\n  ): any[] {\n    return value.map((item: any, index: any) => {\n      if (item === null) {\n        return null;\n      }\n\n      let itemDataId = `${generatedId}.${index}`;\n\n      if (Array.isArray(item)) {\n        return this.processArrayValue(item, itemDataId, selectionSet, context);\n      }\n\n      let generated = true;\n\n      if (context.dataIdFromObject) {\n        const semanticId = context.dataIdFromObject(item);\n\n        if (semanticId) {\n          itemDataId = semanticId;\n          generated = false;\n        }\n      }\n\n      if (!isDataProcessed(itemDataId, selectionSet, context.processedData)) {\n        this.writeSelectionSetToStore({\n          dataId: itemDataId,\n          result: item,\n          selectionSet,\n          context,\n        });\n      }\n\n      return toIdValue(\n        { id: itemDataId, typename: item.__typename },\n        generated,\n      );\n    });\n  }\n}\n\n// Checks if the id given is an id that was generated by Apollo\n// rather than by dataIdFromObject.\nfunction isGeneratedId(id: string): boolean {\n  return id[0] === '$';\n}\n\nfunction mergeWithGenerated(\n  generatedKey: string,\n  realKey: string,\n  cache: NormalizedCache,\n): boolean {\n  if (generatedKey === realKey) {\n    return false;\n  }\n\n  const generated = cache.get(generatedKey);\n  const real = cache.get(realKey);\n  let madeChanges = false;\n\n  Object.keys(generated).forEach(key => {\n    const value = generated[key];\n    const realValue = real[key];\n\n    if (\n      isIdValue(value) &&\n      isGeneratedId(value.id) &&\n      isIdValue(realValue) &&\n      !isEqual(value, realValue) &&\n      mergeWithGenerated(value.id, realValue.id, cache)\n    ) {\n      madeChanges = true;\n    }\n  });\n\n  cache.delete(generatedKey);\n  const newRealValue = { ...generated, ...real };\n\n  if (isEqual(newRealValue, real)) {\n    return madeChanges;\n  }\n\n  cache.set(realKey, newRealValue);\n  return true;\n}\n\nfunction isDataProcessed(\n  dataId: string,\n  field: FieldNode | SelectionSetNode,\n  processedData?: { [x: string]: (FieldNode | SelectionSetNode)[] },\n): boolean {\n  if (!processedData) {\n    return false;\n  }\n\n  if (processedData[dataId]) {\n    if (processedData[dataId].indexOf(field) >= 0) {\n      return true;\n    } else {\n      processedData[dataId].push(field);\n    }\n  } else {\n    processedData[dataId] = [field];\n  }\n\n  return false;\n}\n", "// Make builtins like Map and Set safe to use with non-extensible objects.\nimport './fixPolyfills';\n\nimport { DocumentNode } from 'graphql';\n\nimport { Cache, ApolloCache, Transaction } from 'apollo-cache';\n\nimport { addTypenameToDocument, canUseWeakMap } from 'apollo-utilities';\n\nimport { wrap } from 'optimism';\n\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport { HeuristicFragmentMatcher } from './fragmentMatcher';\nimport {\n  ApolloReducerConfig,\n  NormalizedCache,\n  NormalizedCacheObject,\n} from './types';\n\nimport { StoreReader } from './readFromStore';\nimport { StoreWriter } from './writeToStore';\nimport { DepTrackingCache } from './depTrackingCache';\nimport { KeyTrie } from 'optimism';\nimport { ObjectCache } from './objectCache';\n\nexport interface InMemoryCacheConfig extends ApolloReducerConfig {\n  resultCaching?: boolean;\n  freezeResults?: boolean;\n}\n\nconst defaultConfig: InMemoryCacheConfig = {\n  fragmentMatcher: new HeuristicFragmentMatcher(),\n  dataIdFromObject: defaultDataIdFromObject,\n  addTypename: true,\n  resultCaching: true,\n  freezeResults: false,\n};\n\nexport function defaultDataIdFromObject(result: any): string | null {\n  if (result.__typename) {\n    if (result.id !== undefined) {\n      return `${result.__typename}:${result.id}`;\n    }\n    if (result._id !== undefined) {\n      return `${result.__typename}:${result._id}`;\n    }\n  }\n  return null;\n}\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nexport class OptimisticCacheLayer extends ObjectCache {\n  constructor(\n    public readonly optimisticId: string,\n    // OptimisticCacheLayer objects always wrap some other parent cache, so\n    // this.parent should never be null.\n    public readonly parent: NormalizedCache,\n    public readonly transaction: Transaction<NormalizedCacheObject>,\n  ) {\n    super(Object.create(null));\n  }\n\n  public toObject(): NormalizedCacheObject {\n    return {\n      ...this.parent.toObject(),\n      ...this.data,\n    };\n  }\n\n  // All the other accessor methods of ObjectCache work without knowing about\n  // this.parent, but the get method needs to be overridden to implement the\n  // fallback this.parent.get(dataId) behavior.\n  public get(dataId: string) {\n    return hasOwn.call(this.data, dataId)\n      ? this.data[dataId]\n      : this.parent.get(dataId);\n  }\n}\n\nexport class InMemoryCache extends ApolloCache<NormalizedCacheObject> {\n  private data: NormalizedCache;\n  private optimisticData: NormalizedCache;\n\n  protected config: InMemoryCacheConfig;\n  private watches = new Set<Cache.WatchOptions>();\n  private addTypename: boolean;\n  private typenameDocumentCache = new Map<DocumentNode, DocumentNode>();\n  private storeReader: StoreReader;\n  private storeWriter: StoreWriter;\n  private cacheKeyRoot = new KeyTrie<object>(canUseWeakMap);\n\n  // Set this while in a transaction to prevent broadcasts...\n  // don't forget to turn it back on!\n  private silenceBroadcast: boolean = false;\n\n  constructor(config: InMemoryCacheConfig = {}) {\n    super();\n    this.config = { ...defaultConfig, ...config };\n\n    // backwards compat\n    if ((this.config as any).customResolvers) {\n      invariant.warn(\n        'customResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating customResolvers in the next major version.',\n      );\n      this.config.cacheRedirects = (this.config as any).customResolvers;\n    }\n\n    if ((this.config as any).cacheResolvers) {\n      invariant.warn(\n        'cacheResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating cacheResolvers in the next major version.',\n      );\n      this.config.cacheRedirects = (this.config as any).cacheResolvers;\n    }\n\n    this.addTypename = !!this.config.addTypename;\n\n    // Passing { resultCaching: false } in the InMemoryCache constructor options\n    // will completely disable dependency tracking, which will improve memory\n    // usage but worsen the performance of repeated reads.\n    this.data = this.config.resultCaching\n      ? new DepTrackingCache()\n      : new ObjectCache();\n\n    // When no optimistic writes are currently active, cache.optimisticData ===\n    // cache.data, so there are no additional layers on top of the actual data.\n    // When an optimistic update happens, this.optimisticData will become a\n    // linked list of OptimisticCacheLayer objects that terminates with the\n    // original this.data cache object.\n    this.optimisticData = this.data;\n\n    this.storeWriter = new StoreWriter();\n    this.storeReader = new StoreReader({\n      cacheKeyRoot: this.cacheKeyRoot,\n      freezeResults: config.freezeResults,\n    });\n\n    const cache = this;\n    const { maybeBroadcastWatch } = cache;\n    this.maybeBroadcastWatch = wrap((c: Cache.WatchOptions) => {\n      return maybeBroadcastWatch.call(this, c);\n    }, {\n      makeCacheKey(c: Cache.WatchOptions) {\n        if (c.optimistic) {\n          // If we're reading optimistic data, it doesn't matter if this.data\n          // is a DepTrackingCache, since it will be ignored.\n          return;\n        }\n\n        if (c.previousResult) {\n          // If a previousResult was provided, assume the caller would prefer\n          // to compare the previous data to the new data to determine whether\n          // to broadcast, so we should disable caching by returning here, to\n          // give maybeBroadcastWatch a chance to do that comparison.\n          return;\n        }\n\n        if (cache.data instanceof DepTrackingCache) {\n          // Return a cache key (thus enabling caching) only if we're currently\n          // using a data store that can track cache dependencies.\n          return cache.cacheKeyRoot.lookup(\n            c.query,\n            JSON.stringify(c.variables),\n          );\n        }\n      }\n    });\n  }\n\n  public restore(data: NormalizedCacheObject): this {\n    if (data) this.data.replace(data);\n    return this;\n  }\n\n  public extract(optimistic: boolean = false): NormalizedCacheObject {\n    return (optimistic ? this.optimisticData : this.data).toObject();\n  }\n\n  public read<T>(options: Cache.ReadOptions): T | null {\n    if (typeof options.rootId === 'string' &&\n        typeof this.data.get(options.rootId) === 'undefined') {\n      return null;\n    }\n\n    const { fragmentMatcher } = this.config;\n    const fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;\n\n    return this.storeReader.readQueryFromStore({\n      store: options.optimistic ? this.optimisticData : this.data,\n      query: this.transformDocument(options.query),\n      variables: options.variables,\n      rootId: options.rootId,\n      fragmentMatcherFunction,\n      previousResult: options.previousResult,\n      config: this.config,\n    }) || null;\n  }\n\n  public write(write: Cache.WriteOptions): void {\n    const { fragmentMatcher } = this.config;\n    const fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;\n\n    this.storeWriter.writeResultToStore({\n      dataId: write.dataId,\n      result: write.result,\n      variables: write.variables,\n      document: this.transformDocument(write.query),\n      store: this.data,\n      dataIdFromObject: this.config.dataIdFromObject,\n      fragmentMatcherFunction,\n    });\n\n    this.broadcastWatches();\n  }\n\n  public diff<T>(query: Cache.DiffOptions): Cache.DiffResult<T> {\n    const { fragmentMatcher } = this.config;\n    const fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;\n\n    return this.storeReader.diffQueryAgainstStore({\n      store: query.optimistic ? this.optimisticData : this.data,\n      query: this.transformDocument(query.query),\n      variables: query.variables,\n      returnPartialData: query.returnPartialData,\n      previousResult: query.previousResult,\n      fragmentMatcherFunction,\n      config: this.config,\n    });\n  }\n\n  public watch(watch: Cache.WatchOptions): () => void {\n    this.watches.add(watch);\n\n    return () => {\n      this.watches.delete(watch);\n    };\n  }\n\n  public evict(query: Cache.EvictOptions): Cache.EvictionResult {\n    throw new InvariantError(`eviction is not implemented on InMemory Cache`);\n  }\n\n  public reset(): Promise<void> {\n    this.data.clear();\n    this.broadcastWatches();\n\n    return Promise.resolve();\n  }\n\n  public removeOptimistic(idToRemove: string) {\n    const toReapply: OptimisticCacheLayer[] = [];\n    let removedCount = 0;\n    let layer = this.optimisticData;\n\n    while (layer instanceof OptimisticCacheLayer) {\n      if (layer.optimisticId === idToRemove) {\n        ++removedCount;\n      } else {\n        toReapply.push(layer);\n      }\n      layer = layer.parent;\n    }\n\n    if (removedCount > 0) {\n      // Reset this.optimisticData to the first non-OptimisticCacheLayer object,\n      // which is almost certainly this.data.\n      this.optimisticData = layer;\n\n      // Reapply the layers whose optimistic IDs do not match the removed ID.\n      while (toReapply.length > 0) {\n        const layer = toReapply.pop()!;\n        this.performTransaction(layer.transaction, layer.optimisticId);\n      }\n\n      this.broadcastWatches();\n    }\n  }\n\n  public performTransaction(\n    transaction: Transaction<NormalizedCacheObject>,\n    // This parameter is not part of the performTransaction signature inherited\n    // from the ApolloCache abstract class, but it's useful because it saves us\n    // from duplicating this implementation in recordOptimisticTransaction.\n    optimisticId?: string,\n  ) {\n    const { data, silenceBroadcast } = this;\n    this.silenceBroadcast = true;\n\n    if (typeof optimisticId === 'string') {\n      // Add a new optimistic layer and temporarily make this.data refer to\n      // that layer for the duration of the transaction.\n      this.data = this.optimisticData = new OptimisticCacheLayer(\n        // Note that there can be multiple layers with the same optimisticId.\n        // When removeOptimistic(id) is called for that id, all matching layers\n        // will be removed, and the remaining layers will be reapplied.\n        optimisticId,\n        this.optimisticData,\n        transaction,\n      );\n    }\n\n    try {\n      transaction(this);\n    } finally {\n      this.silenceBroadcast = silenceBroadcast;\n      this.data = data;\n    }\n\n    // This broadcast does nothing if this.silenceBroadcast is true.\n    this.broadcastWatches();\n  }\n\n  public recordOptimisticTransaction(\n    transaction: Transaction<NormalizedCacheObject>,\n    id: string,\n  ) {\n    return this.performTransaction(transaction, id);\n  }\n\n  public transformDocument(document: DocumentNode): DocumentNode {\n    if (this.addTypename) {\n      let result = this.typenameDocumentCache.get(document);\n      if (!result) {\n        result = addTypenameToDocument(document);\n        this.typenameDocumentCache.set(document, result);\n        // If someone calls transformDocument and then mistakenly passes the\n        // result back into an API that also calls transformDocument, make sure\n        // we don't keep creating new query documents.\n        this.typenameDocumentCache.set(result, result);\n      }\n      return result;\n    }\n    return document;\n  }\n\n  protected broadcastWatches() {\n    if (!this.silenceBroadcast) {\n      this.watches.forEach(c => this.maybeBroadcastWatch(c));\n    }\n  }\n\n  // This method is wrapped in the constructor so that it will be called only\n  // if the data that would be broadcast has changed.\n  private maybeBroadcastWatch(c: Cache.WatchOptions) {\n    c.callback(\n      this.diff({\n        query: c.query,\n        variables: c.variables,\n        previousResult: c.previousResult && c.previousResult(),\n        optimistic: c.optimistic,\n      }),\n    );\n  }\n}\n"],
  "mappings": "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",
  "names": ["d", "b", "__assign", "ApolloCache", "Cache", "Slot", "Cache", "Entry", "KeyTrie", "cache", "HeuristicFragmentMatcher", "IntrospectionFragmentMatcher", "DepTrackingCache", "StoreReader", "_a", "ObjectCache", "defaultNormalizedCacheFactory", "WriteError", "StoreWriter", "hasOwn", "OptimisticCacheLayer", "InMemoryCache"]
}
